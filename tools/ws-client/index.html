<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LiveClaw WS Client</title>
    <style>
      :root {
        --bg: #f2efe8;
        --panel: #fffdf8;
        --ink: #1c1f2a;
        --muted: #5f6677;
        --line: #d9d2c4;
        --accent: #007f6f;
        --accent-soft: #d9f3ef;
        --warn: #b54b3a;
        --ok: #2f6f45;
        --out: #0a4b8f;
        --in: #264025;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "IBM Plex Sans", "Avenir Next", "Helvetica Neue", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 10% -10%, #d0ebe5 0%, transparent 35%),
          radial-gradient(circle at 90% 0%, #ffdcb8 0%, transparent 30%),
          linear-gradient(160deg, #f7f4ed 0%, #ece6d9 100%);
      }

      .shell {
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px 18px 36px;
      }

      .hero {
        display: grid;
        gap: 6px;
        margin-bottom: 14px;
      }

      .title {
        font-size: clamp(1.4rem, 2.4vw, 2rem);
        margin: 0;
        letter-spacing: 0.02em;
      }

      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .card {
        border: 1px solid var(--line);
        background: var(--panel);
        border-radius: 12px;
        box-shadow: 0 8px 26px rgba(38, 32, 20, 0.07);
      }

      .status-bar {
        display: grid;
        grid-template-columns: 1fr auto auto auto auto auto auto auto;
        gap: 10px;
        align-items: center;
        padding: 14px;
        margin-bottom: 12px;
      }

      .status-pill {
        justify-self: start;
        border-radius: 999px;
        padding: 6px 12px;
        font-weight: 600;
        font-size: 0.85rem;
        border: 1px solid transparent;
        background: #eceaf2;
      }

      .status-pill.connected {
        color: var(--ok);
        background: #dff2e6;
        border-color: #b8ddc7;
      }

      .status-pill.connecting {
        color: #7a5b00;
        background: #fff2cc;
        border-color: #e3c66f;
      }

      .status-pill.closed,
      .status-pill.error {
        color: var(--warn);
        background: #f8dfdc;
        border-color: #e8b9b2;
      }

      .layout {
        display: grid;
        grid-template-columns: repeat(12, minmax(0, 1fr));
        gap: 12px;
      }

      .span-6 {
        grid-column: span 6;
      }

      .span-12 {
        grid-column: span 12;
      }

      h2 {
        margin: 0 0 12px;
        font-size: 1rem;
      }

      .panel {
        padding: 14px;
      }

      .field-grid {
        display: grid;
        gap: 10px;
      }

      .field-row {
        display: grid;
        gap: 8px;
        grid-template-columns: 1fr auto;
      }

      .field-row.compact {
        grid-template-columns: repeat(2, 1fr);
      }

      .field-row.triple {
        grid-template-columns: repeat(3, 1fr);
      }

      .field-stack {
        display: grid;
        gap: 6px;
      }

      label {
        font-size: 0.83rem;
        color: var(--muted);
      }

      input,
      select,
      textarea,
      button {
        font: inherit;
      }

      input,
      select,
      textarea {
        width: 100%;
        border: 1px solid #cfc7b9;
        background: #fff;
        border-radius: 9px;
        padding: 9px 10px;
        color: var(--ink);
      }

      textarea {
        min-height: 130px;
        resize: vertical;
        font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
        font-size: 0.88rem;
      }

      button {
        border: 1px solid transparent;
        border-radius: 9px;
        padding: 8px 12px;
        cursor: pointer;
        font-weight: 600;
      }

      button.primary {
        background: var(--accent);
        color: #fff;
      }

      button.primary:hover {
        filter: brightness(1.05);
      }

      button.soft {
        background: var(--accent-soft);
        color: #175950;
      }

      button.muted {
        background: #ede6db;
        color: #534f45;
      }

      button.warn {
        background: #f6dfdc;
        color: #7f2d22;
      }

      button.step-pending {
        background: #c54233;
        color: #fff;
        animation: stepBlink 0.9s linear infinite;
      }

      button.step-done {
        background: #2f6f45;
        color: #fff;
      }

      button.step-wait {
        background: #ede6db;
        color: #534f45;
      }

      button:disabled {
        cursor: not-allowed;
        opacity: 0.58;
      }

      @keyframes stepBlink {
        0% {
          opacity: 1;
          box-shadow: 0 0 0 0 rgba(197, 66, 51, 0.6);
        }
        50% {
          opacity: 0.4;
          box-shadow: 0 0 0 6px rgba(197, 66, 51, 0);
        }
        100% {
          opacity: 1;
          box-shadow: 0 0 0 0 rgba(197, 66, 51, 0);
        }
      }

      .hint {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 0.8rem;
      }

      .log {
        background: #1b1c23;
        color: #e9ecf3;
        border-radius: 10px;
        padding: 12px;
        min-height: 260px;
        max-height: 44vh;
        overflow: auto;
        font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
        font-size: 0.82rem;
        line-height: 1.45;
      }

      .line {
        margin: 0 0 6px;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .line.system {
        color: #d4d0f6;
      }

      .line.out {
        color: #9fc9ff;
      }

      .line.in {
        color: #b2f0c4;
      }

      .line.error {
        color: #ffc2ba;
      }

      .badge {
        padding: 5px 10px;
        border: 1px solid #d5cdbf;
        border-radius: 999px;
        font-size: 0.8rem;
        background: #f5f2ea;
      }

      .inline-check {
        display: flex;
        gap: 8px;
        align-items: center;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .inline-check input[type="checkbox"] {
        width: auto;
      }

      .output-pane {
        min-height: 100px;
        max-height: 160px;
        overflow: auto;
        font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
        font-size: 0.84rem;
      }

      @media (max-width: 920px) {
        .status-bar {
          grid-template-columns: 1fr;
        }

        .span-6 {
          grid-column: span 12;
        }

        .field-row,
        .field-row.compact,
        .field-row.triple {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <header class="hero">
        <h1 class="title">LiveClaw Browser WebSocket Client</h1>
        <p class="subtitle">
          Reusable control and audio test console for pairing, session lifecycle, and SessionAudio traffic.
        </p>
      </header>

      <section class="card status-bar">
        <span id="statusPill" class="status-pill closed">closed</span>
        <span class="badge" id="sessionBadge">session: none</span>
        <span class="badge" id="tokenBadge">token: none</span>
        <span class="badge" id="diagBadge">diag: n/a</span>
        <span class="badge" id="secBadge">sec: n/a</span>
        <span class="badge" id="healthBadge">gw: n/a</span>
        <span class="badge" id="prioBadge">prio: n/a</span>
        <button id="clearLog" class="muted">Clear Log</button>
      </section>

      <section class="layout">
        <article class="card panel span-6">
          <h2>Connection and Session</h2>
          <div class="field-grid">
            <div class="field-row">
              <div class="field-stack">
                <label for="wsUrl">WebSocket URL</label>
                <input id="wsUrl" value="ws://127.0.0.1:8420/ws" />
              </div>
              <button id="connectBtn" class="primary">Connect</button>
            </div>
            <div class="field-row">
              <div class="field-stack">
                <label for="pairCode">Pairing Code</label>
                <input id="pairCode" placeholder="e.g. 755810" />
              </div>
              <button id="pairBtn" class="soft">Send Pair</button>
            </div>
            <div class="field-row">
              <div class="field-stack">
                <label for="tokenInput">Token</label>
                <input id="tokenInput" placeholder="auto-filled from PairSuccess" />
              </div>
              <button id="authBtn" class="soft">Authenticate</button>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="roleSelect">Role</label>
                <select id="roleSelect">
                  <option value="">(default)</option>
                  <option value="readonly">readonly</option>
                  <option value="supervised">supervised</option>
                  <option value="full">full</option>
                </select>
              </div>
              <div class="field-stack">
                <label for="graphToggle">Enable Graph</label>
                <select id="graphToggle">
                  <option value="">(default)</option>
                  <option value="true" selected>true</option>
                  <option value="false">false</option>
                </select>
              </div>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="modelInput">Model (optional)</label>
                <input id="modelInput" placeholder="e.g. gpt-4o-realtime-preview" />
              </div>
              <div class="field-stack">
                <label for="voiceInput">Voice (optional)</label>
                <input id="voiceInput" placeholder="e.g. alloy" />
              </div>
            </div>
            <div class="field-row">
              <div class="field-stack">
                <label for="sessionId">Session ID</label>
                <input id="sessionId" placeholder="auto-filled from SessionCreated" />
              </div>
              <button id="createSessionBtn" class="primary">Create Session</button>
            </div>
            <div class="field-row">
              <button id="pingBtn" class="muted">Ping</button>
              <button id="healthBtn" class="muted">Gateway Health</button>
              <button id="priorityBtn" class="soft">Priority Probe</button>
              <button id="diagnosticsBtn" class="soft">Get Diagnostics</button>
              <button id="terminateBtn" class="warn">Terminate Session</button>
            </div>
          </div>
        </article>

        <article class="card panel span-6">
          <h2>Audio Test</h2>
          <div class="field-grid">
            <div class="field-row">
              <div class="field-stack">
                <label for="audioB64">Single Chunk Base64 Audio</label>
                <input id="audioB64" value="AQID" />
              </div>
              <button id="sendB64Btn" class="soft">Send Chunk</button>
            </div>
            <div class="field-stack">
              <label for="audioFile">Upload Audio/PCM File</label>
              <input id="audioFile" type="file" />
            </div>
            <div class="field-row triple">
              <div class="field-stack">
                <label for="chunkSize">Chunk Bytes</label>
                <input id="chunkSize" type="number" min="256" step="256" value="9600" />
              </div>
              <div class="field-stack">
                <label for="chunkDelay">Delay ms</label>
                <input id="chunkDelay" type="number" min="0" step="10" value="120" />
              </div>
              <div class="field-stack">
                <label for="inputRate">Input Sample Rate (Hz)</label>
                <input id="inputRate" type="number" min="8000" step="1000" value="24000" />
              </div>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="playbackRate">Output Sample Rate (Hz)</label>
                <input id="playbackRate" type="number" min="8000" step="1000" value="24000" />
              </div>
              <div class="field-stack">
                <label for="autoPlayOutput">Playback</label>
                <label class="inline-check">
                  <input id="autoPlayOutput" type="checkbox" checked />
                  Auto-play AudioOutput
                </label>
              </div>
            </div>
            <div class="field-row">
              <button id="sendFileBtn" class="primary">Send File as SessionAudio Chunks</button>
              <span id="audioProgress" class="badge">idle</span>
            </div>
            <div class="field-row triple">
              <button id="micStartBtn" class="soft">Start Mic Stream</button>
              <button id="micStopBtn" class="warn" disabled>Stop Mic Stream</button>
              <button id="playLastBtn" class="muted">Play Last Output</button>
            </div>
            <div class="field-row compact">
              <span id="micStatus" class="badge">mic: idle</span>
              <span id="playbackStatus" class="badge">play: idle</span>
            </div>
            <div class="field-row triple">
              <button id="commitAudioBtn" class="muted">Commit Audio</button>
              <button id="createResponseBtn" class="soft">Create Response</button>
              <button id="interruptResponseBtn" class="warn">Interrupt Response</button>
            </div>
            <div class="field-stack">
              <label for="transcriptView">Session Transcript View</label>
              <textarea
                id="transcriptView"
                class="output-pane"
                readonly
                placeholder="TranscriptUpdate deltas for the active session appear here."
              ></textarea>
            </div>
            <p class="hint">
              Upload accepts common browser-decodable audio and converts to PCM16 mono. For raw files, use .pcm.
            </p>
          </div>
        </article>

        <article class="card panel span-6">
          <h2>Tool + Graph (M3)</h2>
          <div class="field-grid">
            <div class="field-row compact">
              <div class="field-stack">
                <label for="toolName">Tool Name</label>
                <select id="toolName">
                  <option value="echo_text">echo_text</option>
                  <option value="add_numbers">add_numbers</option>
                  <option value="utc_time">utc_time</option>
                  <option value="read_workspace_file">read_workspace_file</option>
                </select>
              </div>
              <div class="field-stack">
                <label>&nbsp;</label>
                <button id="callToolBtn" class="primary">SessionToolCall</button>
              </div>
            </div>
            <div class="field-stack">
              <label for="toolArgs">Tool Arguments (JSON)</label>
              <textarea id="toolArgs" class="output-pane" spellcheck="false">{
  "text": "hello from graph"
}</textarea>
            </div>
            <div class="field-stack">
              <label for="toolResultView">Tool Result</label>
              <textarea id="toolResultView" class="output-pane" readonly></textarea>
            </div>
            <div class="field-stack">
              <label for="graphTraceView">Graph Trace</label>
              <textarea id="graphTraceView" class="output-pane" readonly></textarea>
            </div>
            <div class="field-stack">
              <label for="promptInput">Prompt (LLM decides tool call)</label>
              <textarea
                id="promptInput"
                class="output-pane"
                spellcheck="false"
              >Use add_numbers with a=12 and b=30, then answer with the computed sum.</textarea>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="summaryFilePath">Workspace File Path</label>
                <input id="summaryFilePath" value="README.md" placeholder="e.g. docs/design.md" />
              </div>
              <div class="field-stack">
                <label for="summaryBullets">Summary Bullets</label>
                <select id="summaryBullets">
                  <option value="3">3</option>
                  <option value="5" selected>5</option>
                  <option value="8">8</option>
                </select>
              </div>
            </div>
            <div class="field-row compact">
              <button id="runReadSummaryBtn" class="primary">Run Read + Summarize</button>
              <button id="applyReadSummaryPromptBtn" class="muted">Apply Prompt Only</button>
            </div>
            <div class="field-row">
              <button id="sendPromptBtn" class="soft">Send Prompt</button>
            </div>
            <div class="field-stack">
              <label for="promptToolActivityView">Prompt Tool Activity</label>
              <textarea
                id="promptToolActivityView"
                class="output-pane"
                readonly
                placeholder="Prompt-driven SessionToolResult events are summarized here."
              ></textarea>
            </div>
            <p class="hint">
              Prompt file-read summaries trigger `read_workspace_file` automatically. SessionToolCall runs with graph if enabled, and direct mode otherwise.
            </p>
          </div>
        </article>

        <article class="card panel span-6">
          <h2>M4 Evidence (Memory, Artifacts, Resilience)</h2>
          <div class="field-grid">
            <div class="field-row compact">
              <button id="refreshM4Btn" class="primary">Refresh Diagnostics</button>
              <button id="captureM4Btn" class="soft">Capture Evidence Snapshot</button>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="memoryProbePath">Memory Probe Path</label>
                <input id="memoryProbePath" value="liveclaw-memory.json" placeholder="workspace-relative file" />
              </div>
              <div class="field-stack">
                <label for="artifactProbePath">Artifact Probe Path</label>
                <input id="artifactProbePath" value="artifacts" placeholder="workspace-relative file/dir" />
              </div>
            </div>
            <div class="field-row compact">
              <button id="probeMemoryBtn" class="muted">Probe Memory File</button>
              <button id="probeArtifactBtn" class="muted">Probe Artifact Path</button>
            </div>
            <div class="field-stack">
              <label for="m4EvidenceView">M4 Evidence View</label>
              <textarea
                id="m4EvidenceView"
                class="output-pane"
                readonly
                placeholder="Snapshots include diagnostics counters, observed session traffic, and probe outcomes."
              ></textarea>
            </div>
            <p class="hint">
              Use file-backed memory and enabled artifacts in config for strongest persistence evidence. Diagnostics provide resilience + compaction state.
            </p>
          </div>
        </article>

        <article class="card panel span-6">
          <h2>Channel Bridge</h2>
          <div class="field-grid">
            <div class="field-row triple">
              <div class="field-stack">
                <label for="channelType">Channel</label>
                <select id="channelType">
                  <option value="telegram">telegram</option>
                  <option value="slack">slack</option>
                  <option value="webhook">webhook</option>
                </select>
              </div>
              <div class="field-stack">
                <label for="channelAccountId">Account ID</label>
                <input id="channelAccountId" value="acct-1" placeholder="workspace/account id" />
              </div>
              <div class="field-stack">
                <label for="channelExternalUserId">External User ID</label>
                <input id="channelExternalUserId" value="user-1" placeholder="channel user id" />
              </div>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="channelOutboundMax">Outbound Poll Max</label>
                <input id="channelOutboundMax" type="number" min="1" max="500" value="20" />
              </div>
              <div class="field-stack">
                <label>&nbsp;</label>
                <button id="pollChannelOutboundBtn" class="soft">Poll Channel Outbound</button>
              </div>
            </div>
            <div class="field-stack">
              <label for="channelText">Inbound Text</label>
              <textarea id="channelText" placeholder="Message from channel user">Hello from channel bridge.</textarea>
            </div>
            <label class="inline-check">
              <input id="channelCreateResponse" type="checkbox" checked />
              Create model response after route
            </label>
            <div class="field-row">
              <button id="routeChannelBtn" class="primary">Route Channel Inbound</button>
            </div>
            <div class="field-stack">
              <label for="channelRouteView">Channel Route Activity</label>
              <textarea
                id="channelRouteView"
                class="output-pane"
                readonly
                placeholder="ChannelRouted events will appear here."
              ></textarea>
            </div>
            <div class="field-stack">
              <label for="channelOutboundView">Channel Outbound Activity</label>
              <textarea
                id="channelOutboundView"
                class="output-pane"
                readonly
                placeholder="ChannelOutboundBatch items will appear here."
              ></textarea>
            </div>
            <p class="hint">
              Routes are isolated by principal + channel + account_id + external_user_id. Reusing the same key should return the same session.
            </p>
          </div>
        </article>

        <article class="card panel span-12">
          <h2>Raw JSON Message</h2>
          <div class="field-grid">
            <div class="field-row compact">
              <div class="field-stack">
                <label for="templateType">Message Template</label>
                <select id="templateType">
                  <option value="Ping">Ping</option>
                  <option value="GetGatewayHealth">GetGatewayHealth</option>
                  <option value="PriorityProbe">PriorityProbe</option>
                  <option value="GetDiagnostics">GetDiagnostics</option>
                  <option value="CreateSession">CreateSession</option>
                  <option value="TerminateSession">TerminateSession</option>
                  <option value="SessionAudio">SessionAudio</option>
                  <option value="SessionAudioCommit">SessionAudioCommit</option>
                  <option value="SessionResponseCreate">SessionResponseCreate</option>
                  <option value="SessionResponseInterrupt">SessionResponseInterrupt</option>
                  <option value="SessionPrompt">SessionPrompt</option>
                  <option value="ChannelInbound">ChannelInbound</option>
                  <option value="GetChannelOutbound">GetChannelOutbound</option>
                  <option value="SessionToolCall">SessionToolCall</option>
                </select>
              </div>
              <div class="field-stack">
                <label>&nbsp;</label>
                <button id="loadTemplateBtn" class="soft">Load Template</button>
              </div>
            </div>
            <textarea id="rawJson" spellcheck="false">{"type":"Ping"}</textarea>
            <div class="field-row">
              <button id="sendRawBtn" class="primary">Send JSON</button>
              <button id="disconnectBtn" class="muted">Disconnect</button>
            </div>
          </div>
        </article>

        <article class="card panel span-12">
          <h2>Traffic Log</h2>
          <div id="log" class="log" aria-live="polite"></div>
        </article>
      </section>
    </main>

    <script>
      (() => {
        const $ = (id) => document.getElementById(id);

        const els = {
          statusPill: $("statusPill"),
          sessionBadge: $("sessionBadge"),
          tokenBadge: $("tokenBadge"),
          diagBadge: $("diagBadge"),
          secBadge: $("secBadge"),
          healthBadge: $("healthBadge"),
          prioBadge: $("prioBadge"),
          wsUrl: $("wsUrl"),
          connectBtn: $("connectBtn"),
          disconnectBtn: $("disconnectBtn"),
          clearLog: $("clearLog"),
          pairCode: $("pairCode"),
          pairBtn: $("pairBtn"),
          tokenInput: $("tokenInput"),
          authBtn: $("authBtn"),
          roleSelect: $("roleSelect"),
          graphToggle: $("graphToggle"),
          modelInput: $("modelInput"),
          voiceInput: $("voiceInput"),
          createSessionBtn: $("createSessionBtn"),
          sessionId: $("sessionId"),
          pingBtn: $("pingBtn"),
          healthBtn: $("healthBtn"),
          priorityBtn: $("priorityBtn"),
          diagnosticsBtn: $("diagnosticsBtn"),
          terminateBtn: $("terminateBtn"),
          audioB64: $("audioB64"),
          sendB64Btn: $("sendB64Btn"),
          audioFile: $("audioFile"),
          chunkSize: $("chunkSize"),
          chunkDelay: $("chunkDelay"),
          inputRate: $("inputRate"),
          playbackRate: $("playbackRate"),
          autoPlayOutput: $("autoPlayOutput"),
          sendFileBtn: $("sendFileBtn"),
          audioProgress: $("audioProgress"),
          micStartBtn: $("micStartBtn"),
          micStopBtn: $("micStopBtn"),
          micStatus: $("micStatus"),
          playLastBtn: $("playLastBtn"),
          playbackStatus: $("playbackStatus"),
          commitAudioBtn: $("commitAudioBtn"),
          createResponseBtn: $("createResponseBtn"),
          interruptResponseBtn: $("interruptResponseBtn"),
          transcriptView: $("transcriptView"),
          toolName: $("toolName"),
          toolArgs: $("toolArgs"),
          callToolBtn: $("callToolBtn"),
          toolResultView: $("toolResultView"),
          graphTraceView: $("graphTraceView"),
          promptInput: $("promptInput"),
          summaryFilePath: $("summaryFilePath"),
          summaryBullets: $("summaryBullets"),
          runReadSummaryBtn: $("runReadSummaryBtn"),
          applyReadSummaryPromptBtn: $("applyReadSummaryPromptBtn"),
          promptToolActivityView: $("promptToolActivityView"),
          refreshM4Btn: $("refreshM4Btn"),
          captureM4Btn: $("captureM4Btn"),
          memoryProbePath: $("memoryProbePath"),
          artifactProbePath: $("artifactProbePath"),
          probeMemoryBtn: $("probeMemoryBtn"),
          probeArtifactBtn: $("probeArtifactBtn"),
          m4EvidenceView: $("m4EvidenceView"),
          channelType: $("channelType"),
          channelAccountId: $("channelAccountId"),
          channelExternalUserId: $("channelExternalUserId"),
          channelOutboundMax: $("channelOutboundMax"),
          pollChannelOutboundBtn: $("pollChannelOutboundBtn"),
          channelText: $("channelText"),
          channelCreateResponse: $("channelCreateResponse"),
          routeChannelBtn: $("routeChannelBtn"),
          channelRouteView: $("channelRouteView"),
          channelOutboundView: $("channelOutboundView"),
          sendPromptBtn: $("sendPromptBtn"),
          rawJson: $("rawJson"),
          sendRawBtn: $("sendRawBtn"),
          templateType: $("templateType"),
          loadTemplateBtn: $("loadTemplateBtn"),
          log: $("log"),
        };

        const keys = {
          wsUrl: "liveclaw.ws.url",
          token: "liveclaw.ws.token",
          sessionId: "liveclaw.ws.session_id",
          summaryFilePath: "liveclaw.ws.summary_file_path",
          summaryBullets: "liveclaw.ws.summary_bullets",
          memoryProbePath: "liveclaw.ws.memory_probe_path",
          artifactProbePath: "liveclaw.ws.artifact_probe_path",
          channelType: "liveclaw.ws.channel_type",
          channelAccountId: "liveclaw.ws.channel_account_id",
          channelExternalUserId: "liveclaw.ws.channel_external_user_id",
          channelOutboundMax: "liveclaw.ws.channel_outbound_max",
        };

        const DEFAULT_SAMPLE_RATE = 24000;
        const MIC_BUFFER_SIZE = 4096;
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const OfflineCtx = window.OfflineAudioContext || window.webkitOfflineAudioContext;

        let ws = null;
        let playbackContext = null;
        let playbackCursor = 0;
        let lastAudioOutputBytes = null;
        const voiceCounters = {
          accepted: 0,
          transcript: 0,
          audioOutput: 0,
        };

        const m4State = {
          lastDiagnostics: null,
          snapshots: [],
          toolResultCount: 0,
          transcriptChars: 0,
          lastToolSummary: "n/a",
          lastError: "",
        };

        const flowState = {
          requirePairing: true,
          paired: false,
          authenticated: false,
          sessionReady: false,
          readySessionId: "",
        };

        const micState = {
          stream: null,
          context: null,
          source: null,
          processor: null,
          sink: null,
          active: false,
        };

        const now = () => new Date().toLocaleTimeString();
        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        function log(kind, text) {
          const line = document.createElement("div");
          line.className = `line ${kind}`;
          line.textContent = `[${now()}] ${text}`;
          els.log.appendChild(line);
          els.log.scrollTop = els.log.scrollHeight;
        }

        function setStatus(state, details = "") {
          els.statusPill.className = `status-pill ${state}`;
          els.statusPill.textContent = details ? `${state} - ${details}` : state;
        }

        function setMicStatus(text) {
          els.micStatus.textContent = `mic: ${text}`;
        }

        function setPlaybackStatus(text) {
          els.playbackStatus.textContent = `play: ${text}`;
        }

        function parseRate(value, fallback) {
          const num = Number(value);
          if (!Number.isFinite(num) || num <= 0) return fallback;
          return Math.floor(num);
        }

        function activeSessionId() {
          return els.sessionId.value.trim();
        }

        function hasOpenSocket() {
          return Boolean(ws && ws.readyState === WebSocket.OPEN);
        }

        function setButtonVariant(button, variant) {
          const variants = ["primary", "soft", "muted", "warn", "step-pending", "step-done", "step-wait"];
          for (const v of variants) {
            button.classList.remove(v);
          }
          button.classList.add(variant);
        }

        function resetFlowState() {
          flowState.requirePairing = true;
          flowState.paired = false;
          flowState.authenticated = false;
          flowState.sessionReady = false;
          flowState.readySessionId = "";
        }

        function refreshFlowControls() {
          const open = hasOpenSocket();
          const authRequired = flowState.requirePairing;

          if (open) {
            setButtonVariant(els.connectBtn, "warn");
            els.connectBtn.textContent = "Disconnect";
          } else {
            setButtonVariant(els.connectBtn, "primary");
            els.connectBtn.textContent = "Connect";
          }
          els.disconnectBtn.disabled = !open;

          if (!open) {
            setButtonVariant(els.pairBtn, "step-wait");
            els.pairBtn.textContent = "Send Pair";
            els.pairBtn.disabled = true;
          } else if (!flowState.requirePairing) {
            setButtonVariant(els.pairBtn, "step-done");
            els.pairBtn.textContent = "Pair N/A";
            els.pairBtn.disabled = true;
          } else if (flowState.paired) {
            setButtonVariant(els.pairBtn, "step-done");
            els.pairBtn.textContent = "Paired";
            els.pairBtn.disabled = true;
          } else {
            setButtonVariant(els.pairBtn, "step-pending");
            els.pairBtn.textContent = "Send Pair";
            els.pairBtn.disabled = false;
          }

          if (!open) {
            setButtonVariant(els.authBtn, "step-wait");
            els.authBtn.textContent = "Authenticate";
            els.authBtn.disabled = true;
          } else if (!authRequired) {
            setButtonVariant(els.authBtn, "step-done");
            els.authBtn.textContent = "Auth N/A";
            els.authBtn.disabled = true;
          } else if (!flowState.paired) {
            setButtonVariant(els.authBtn, "step-wait");
            els.authBtn.textContent = "Authenticate";
            els.authBtn.disabled = true;
          } else if (flowState.authenticated) {
            setButtonVariant(els.authBtn, "step-done");
            els.authBtn.textContent = "Authenticated";
            els.authBtn.disabled = true;
          } else {
            setButtonVariant(els.authBtn, "soft");
            els.authBtn.textContent = "Authenticate";
            els.authBtn.disabled = false;
          }

          const canCreateSession = open && (!authRequired || flowState.authenticated) && !flowState.sessionReady;
          if (flowState.sessionReady) {
            setButtonVariant(els.createSessionBtn, "step-done");
            els.createSessionBtn.textContent = "Session Ready";
          } else {
            setButtonVariant(els.createSessionBtn, "primary");
            els.createSessionBtn.textContent = "Create Session";
          }
          els.createSessionBtn.disabled = !canCreateSession;
        }

        function refreshMicControls() {
          const hasSession = Boolean(activeSessionId());
          els.micStartBtn.disabled = micState.active || !hasSession || !hasOpenSocket();
          els.micStopBtn.disabled = !micState.active;
        }

        function updateBadges() {
          const sid = activeSessionId();
          const tok = els.tokenInput.value.trim();
          els.sessionBadge.textContent = sid ? `session: ${sid}` : "session: none";
          els.tokenBadge.textContent = tok ? `token: ${tok.slice(0, 12)}...` : "token: none";
          if (!sid || sid !== flowState.readySessionId) {
            flowState.sessionReady = false;
          }
          refreshMicControls();
          refreshFlowControls();
        }

        function resetSessionOutputState() {
          voiceCounters.accepted = 0;
          voiceCounters.transcript = 0;
          voiceCounters.audioOutput = 0;
          lastAudioOutputBytes = null;
          m4State.toolResultCount = 0;
          m4State.transcriptChars = 0;
          m4State.lastToolSummary = "n/a";
          m4State.lastError = "";
          m4State.snapshots = [];
          els.transcriptView.value = "";
          els.toolResultView.value = "";
          els.graphTraceView.value = "";
          els.promptToolActivityView.value = "";
          els.channelRouteView.value = "";
          els.channelOutboundView.value = "";
          els.m4EvidenceView.value = "";
          els.audioProgress.textContent = "idle";
          setPlaybackStatus("idle");
          updateM4EvidenceView();
        }

        function savePrefs() {
          localStorage.setItem(keys.wsUrl, els.wsUrl.value.trim());
          localStorage.setItem(keys.token, els.tokenInput.value.trim());
          localStorage.setItem(keys.sessionId, activeSessionId());
          localStorage.setItem(keys.summaryFilePath, els.summaryFilePath.value.trim());
          localStorage.setItem(keys.summaryBullets, els.summaryBullets.value.trim());
          localStorage.setItem(keys.memoryProbePath, els.memoryProbePath.value.trim());
          localStorage.setItem(keys.artifactProbePath, els.artifactProbePath.value.trim());
          localStorage.setItem(keys.channelType, els.channelType.value.trim());
          localStorage.setItem(keys.channelAccountId, els.channelAccountId.value.trim());
          localStorage.setItem(keys.channelExternalUserId, els.channelExternalUserId.value.trim());
          localStorage.setItem(keys.channelOutboundMax, els.channelOutboundMax.value.trim());
        }

        function loadPrefs() {
          const url = localStorage.getItem(keys.wsUrl);
          const token = localStorage.getItem(keys.token);
          const sid = localStorage.getItem(keys.sessionId);
          const summaryFilePath = localStorage.getItem(keys.summaryFilePath);
          const summaryBullets = localStorage.getItem(keys.summaryBullets);
          const memoryProbePath = localStorage.getItem(keys.memoryProbePath);
          const artifactProbePath = localStorage.getItem(keys.artifactProbePath);
          const channelType = localStorage.getItem(keys.channelType);
          const channelAccountId = localStorage.getItem(keys.channelAccountId);
          const channelExternalUserId = localStorage.getItem(keys.channelExternalUserId);
          const channelOutboundMax = localStorage.getItem(keys.channelOutboundMax);
          if (url) els.wsUrl.value = url;
          if (token) els.tokenInput.value = token;
          if (sid) els.sessionId.value = sid;
          if (summaryFilePath) els.summaryFilePath.value = summaryFilePath;
          if (summaryBullets) {
            const matches = [...els.summaryBullets.options].some((opt) => opt.value === summaryBullets);
            if (matches) els.summaryBullets.value = summaryBullets;
          }
          if (memoryProbePath) els.memoryProbePath.value = memoryProbePath;
          if (artifactProbePath) els.artifactProbePath.value = artifactProbePath;
          if (channelType) {
            const matches = [...els.channelType.options].some((opt) => opt.value === channelType);
            if (matches) els.channelType.value = channelType;
          }
          if (channelAccountId) els.channelAccountId.value = channelAccountId;
          if (channelExternalUserId) els.channelExternalUserId.value = channelExternalUserId;
          if (channelOutboundMax) els.channelOutboundMax.value = channelOutboundMax;
          updateBadges();
          updateM4EvidenceView();
        }

        function requireOpenSocket() {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            log("error", "Socket is not open. Connect first.");
            return false;
          }
          return true;
        }

        function sendObject(message, options = {}) {
          if (!requireOpenSocket()) return false;
          const serialized = JSON.stringify(message);
          ws.send(serialized);
          if (!options.silent) {
            log("out", serialized);
          }
          return true;
        }

        function parseJson(text) {
          try {
            return JSON.parse(text);
          } catch (err) {
            log("error", `Invalid JSON: ${err.message}`);
            return null;
          }
        }

        function legacyGetUserMediaFn() {
          return (
            navigator.getUserMedia ||
            navigator.webkitGetUserMedia ||
            navigator.mozGetUserMedia ||
            navigator.msGetUserMedia
          );
        }

        async function requestMicrophoneStream(constraints) {
          if (navigator.mediaDevices?.getUserMedia) {
            return navigator.mediaDevices.getUserMedia(constraints);
          }

          const legacy = legacyGetUserMediaFn();
          if (!legacy) {
            throw new Error(
              "Microphone API unavailable. Use a recent Chrome/Edge/Safari and open the client over http://127.0.0.1 or https."
            );
          }

          return new Promise((resolve, reject) => {
            legacy.call(navigator, constraints, resolve, reject);
          });
        }

        function syncTemplateOptions(types) {
          if (!Array.isArray(types) || types.length === 0) return;
          const prev = els.templateType.value;
          els.templateType.innerHTML = "";
          for (const t of types) {
            const opt = document.createElement("option");
            opt.value = t;
            opt.textContent = t;
            els.templateType.appendChild(opt);
          }
          if ([...types].includes(prev)) {
            els.templateType.value = prev;
          }
        }

        function templateForType(type) {
          const sid = activeSessionId() || "<SESSION_ID>";
          const token = els.tokenInput.value.trim() || "<TOKEN>";
          const code = els.pairCode.value.trim() || "<PAIRING_CODE>";
          switch (type) {
            case "Pair":
              return { type: "Pair", code };
            case "Authenticate":
              return { type: "Authenticate", token };
            case "CreateSession":
              return buildCreateSessionMessage();
            case "TerminateSession":
              return { type: "TerminateSession", session_id: sid };
            case "SessionAudio":
              return {
                type: "SessionAudio",
                session_id: sid,
                audio: els.audioB64.value.trim() || "AQID",
              };
            case "SessionAudioCommit":
              return { type: "SessionAudioCommit", session_id: sid };
            case "SessionResponseCreate":
              return { type: "SessionResponseCreate", session_id: sid };
            case "SessionResponseInterrupt":
              return { type: "SessionResponseInterrupt", session_id: sid };
            case "SessionPrompt":
              return {
                type: "SessionPrompt",
                session_id: sid,
                prompt: els.promptInput.value.trim() || "Use utc_time and report UTC timestamp.",
                create_response: true,
              };
            case "ChannelInbound":
              return {
                type: "ChannelInbound",
                channel: els.channelType.value || "telegram",
                account_id: els.channelAccountId.value.trim() || "acct-1",
                external_user_id: els.channelExternalUserId.value.trim() || "user-1",
                text: els.channelText.value.trim() || "Hello from channel bridge.",
                create_response: Boolean(els.channelCreateResponse.checked),
              };
            case "GetChannelOutbound":
              return {
                type: "GetChannelOutbound",
                channel: els.channelType.value || "telegram",
                account_id: els.channelAccountId.value.trim() || "acct-1",
                external_user_id: els.channelExternalUserId.value.trim() || "user-1",
                max_items: parseRate(els.channelOutboundMax.value, 20),
              };
            case "SessionToolCall": {
              const toolName = els.toolName.value.trim() || "echo_text";
              const parsedArgs = parseJson(els.toolArgs.value) || { text: "hello from graph" };
              return {
                type: "SessionToolCall",
                session_id: sid,
                tool_name: toolName,
                arguments: parsedArgs,
              };
            }
            case "GetDiagnostics":
              return { type: "GetDiagnostics" };
            case "GetGatewayHealth":
              return { type: "GetGatewayHealth" };
            case "PriorityProbe":
              return { type: "PriorityProbe" };
            case "Ping":
            default:
              return { type: "Ping" };
          }
        }

        function quietParseJson(text) {
          try {
            return JSON.parse(text);
          } catch {
            return null;
          }
        }

        function defaultToolArgsFor(toolName) {
          if (toolName === "read_workspace_file") {
            return {
              path: els.summaryFilePath.value.trim() || "README.md",
              max_bytes: 16384,
            };
          }
          if (toolName === "add_numbers") {
            return { a: 12, b: 30 };
          }
          if (toolName === "utc_time") {
            return {};
          }
          return { text: "hello from graph" };
        }

        function maybeApplyToolArgsPreset() {
          const toolName = els.toolName.value.trim();
          const parsed = quietParseJson(els.toolArgs.value);
          const shouldApply =
            !parsed ||
            (toolName === "read_workspace_file" && parsed.path === undefined) ||
            (toolName !== "read_workspace_file" && parsed.path !== undefined && parsed.text === undefined);
          if (!shouldApply) return;
          els.toolArgs.value = JSON.stringify(defaultToolArgsFor(toolName), null, 2);
        }

        function buildReadSummaryPrompt(filePath, bulletCount) {
          const safePath = (filePath || "README.md").trim() || "README.md";
          const bullets = Number(bulletCount) > 0 ? Number(bulletCount) : 5;
          return `Use read_workspace_file to read ${safePath}, then return a concise ${bullets}-bullet summary of the file.`;
        }

        function appendPromptToolActivity(text) {
          if (!text) return;
          const existing = els.promptToolActivityView.value;
          els.promptToolActivityView.value = existing ? `${existing}\n${text}` : text;
          els.promptToolActivityView.scrollTop = els.promptToolActivityView.scrollHeight;
        }

        function appendChannelRouteActivity(text) {
          if (!text) return;
          const existing = els.channelRouteView.value;
          els.channelRouteView.value = existing ? `${existing}\n${text}` : text;
          els.channelRouteView.scrollTop = els.channelRouteView.scrollHeight;
        }

        function appendChannelOutboundActivity(text) {
          if (!text) return;
          const existing = els.channelOutboundView.value;
          els.channelOutboundView.value = existing ? `${existing}\n${text}` : text;
          els.channelOutboundView.scrollTop = els.channelOutboundView.scrollHeight;
        }

        function describeToolResultForActivity(parsed) {
          const toolName = parsed.tool_name || "unknown";
          const result = parsed.result || {};
          const status = result.status || "unknown";
          const report = parsed.graph || {};
          const executionMode = report.final_state?.execution_mode || (report.events?.length ? "graph" : "n/a");
          if (toolName === "read_workspace_file" && result.result) {
            const r = result.result;
            const path = r.path || "n/a";
            const bytes = Number(r.bytes_read || 0);
            const truncated = Boolean(r.truncated);
            return `[${now()}] ${toolName} ${status} path=${path} bytes=${bytes} truncated=${truncated} mode=${executionMode}`;
          }
          return `[${now()}] ${toolName} ${status} mode=${executionMode}`;
        }

        function summarizeToolResult(parsed) {
          const toolName = parsed.tool_name || "unknown";
          const result = parsed.result || {};
          const status = result.status || "unknown";
          const report = parsed.graph || {};
          const mode = report.final_state?.execution_mode || (Array.isArray(report.events) && report.events.length ? "graph" : "n/a");
          if (toolName === "read_workspace_file" && result.result) {
            const rr = result.result;
            return `${toolName} ${status} path=${rr.path || "n/a"} bytes=${Number(rr.bytes_read || 0)} truncated=${Boolean(rr.truncated)} mode=${mode}`;
          }
          return `${toolName} ${status} mode=${mode}`;
        }

        function updateM4EvidenceView() {
          const sid = activeSessionId() || "none";
          const diag = m4State.lastDiagnostics || {};
          const lines = [];
          lines.push(`session_id: ${sid}`);
          lines.push(`captured_at: ${new Date().toISOString()}`);
          lines.push("");
          lines.push("observed_session_evidence:");
          lines.push(`- transcript_chunks=${voiceCounters.transcript}`);
          lines.push(`- transcript_chars=${m4State.transcriptChars}`);
          lines.push(`- audio_output_events=${voiceCounters.audioOutput}`);
          lines.push(`- tool_result_events=${m4State.toolResultCount}`);
          lines.push(`- last_tool_result=${m4State.lastToolSummary}`);
          lines.push("");
          lines.push("resilience_diagnostics:");
          lines.push(`- reconnect_enabled=${diag.reconnect_enabled ?? "n/a"}`);
          lines.push(`- reconnect_max_attempts=${diag.reconnect_max_attempts ?? "n/a"}`);
          lines.push(`- reconnect_attempts_total=${diag.reconnect_attempts_total ?? "n/a"}`);
          lines.push(`- reconnect_successes_total=${diag.reconnect_successes_total ?? "n/a"}`);
          lines.push(`- reconnect_failures_total=${diag.reconnect_failures_total ?? "n/a"}`);
          lines.push("");
          lines.push("memory_compaction_diagnostics:");
          lines.push(`- compaction_enabled=${diag.compaction_enabled ?? "n/a"}`);
          lines.push(`- compaction_max_events_threshold=${diag.compaction_max_events_threshold ?? "n/a"}`);
          lines.push(`- compactions_applied_total=${diag.compactions_applied_total ?? "n/a"}`);
          lines.push("");
          lines.push("recent_snapshots:");
          if (m4State.snapshots.length === 0) {
            lines.push("- none");
          } else {
            for (const s of m4State.snapshots.slice(-8)) {
              lines.push(`- [${s.time}] ${s.note}`);
            }
          }
          if (m4State.lastError) {
            lines.push("");
            lines.push(`last_error: ${m4State.lastError}`);
          }
          els.m4EvidenceView.value = lines.join("\n");
          els.m4EvidenceView.scrollTop = els.m4EvidenceView.scrollHeight;
        }

        function recordM4Snapshot(note) {
          m4State.snapshots.push({
            time: now(),
            note,
          });
          if (m4State.snapshots.length > 24) {
            m4State.snapshots.shift();
          }
          updateM4EvidenceView();
        }

        function bytesToBase64(bytes) {
          let binary = "";
          for (let i = 0; i < bytes.length; i += 1) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        }

        function base64ToBytes(audioB64) {
          const binary = atob(audioB64);
          const out = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i += 1) {
            out[i] = binary.charCodeAt(i);
          }
          return out;
        }

        function float32ToPcm16Bytes(samples) {
          const out = new Uint8Array(samples.length * 2);
          for (let i = 0; i < samples.length; i += 1) {
            const sample = Math.max(-1, Math.min(1, samples[i]));
            const value = sample < 0 ? Math.round(sample * 0x8000) : Math.round(sample * 0x7fff);
            out[i * 2] = value & 0xff;
            out[i * 2 + 1] = (value >> 8) & 0xff;
          }
          return out;
        }

        function pcm16BytesToFloat32(bytes) {
          const sampleCount = Math.floor(bytes.length / 2);
          const out = new Float32Array(sampleCount);
          for (let i = 0; i < sampleCount; i += 1) {
            const lo = bytes[i * 2];
            const hi = bytes[i * 2 + 1];
            let sample = (hi << 8) | lo;
            if (sample & 0x8000) sample -= 0x10000;
            out[i] = sample / 32768;
          }
          return out;
        }

        function resampleFloat32Linear(samples, sourceRate, targetRate) {
          if (sourceRate === targetRate) {
            return samples;
          }
          const ratio = sourceRate / targetRate;
          const outLength = Math.max(1, Math.round(samples.length / ratio));
          const out = new Float32Array(outLength);
          for (let i = 0; i < outLength; i += 1) {
            const sourceIndex = i * ratio;
            const low = Math.floor(sourceIndex);
            const high = Math.min(low + 1, samples.length - 1);
            const weight = sourceIndex - low;
            out[i] = samples[low] * (1 - weight) + samples[high] * weight;
          }
          return out;
        }

        function inputBufferToMono(inputBuffer) {
          if (inputBuffer.numberOfChannels <= 1) {
            return new Float32Array(inputBuffer.getChannelData(0));
          }
          const mono = new Float32Array(inputBuffer.length);
          for (let c = 0; c < inputBuffer.numberOfChannels; c += 1) {
            const channel = inputBuffer.getChannelData(c);
            for (let i = 0; i < inputBuffer.length; i += 1) {
              mono[i] += channel[i];
            }
          }
          for (let i = 0; i < mono.length; i += 1) {
            mono[i] /= inputBuffer.numberOfChannels;
          }
          return mono;
        }

        function isRawPcmFile(file) {
          const name = (file?.name || "").toLowerCase();
          return name.endsWith(".pcm") || name.endsWith(".raw") || name.endsWith(".s16le");
        }

        async function decodeFileToPcm16(file, targetRate) {
          if (isRawPcmFile(file)) {
            return new Uint8Array(await file.arrayBuffer());
          }

          if (!AudioCtx || !OfflineCtx) {
            throw new Error("Web Audio API is not available in this browser.");
          }

          const decodeContext = new AudioCtx();
          try {
            const inputBuffer = await file.arrayBuffer();
            const decoded = await decodeContext.decodeAudioData(inputBuffer.slice(0));
            const frameCount = Math.max(1, Math.ceil(decoded.duration * targetRate));
            const offline = new OfflineCtx(1, frameCount, targetRate);
            const source = offline.createBufferSource();
            source.buffer = decoded;
            source.connect(offline.destination);
            source.start(0);
            const rendered = await offline.startRendering();
            return float32ToPcm16Bytes(rendered.getChannelData(0));
          } finally {
            decodeContext.close().catch(() => {});
          }
        }

        async function ensurePlaybackContext(sampleRate) {
          if (!AudioCtx) {
            throw new Error("Audio playback is not supported in this browser.");
          }
          if (!playbackContext) {
            playbackContext = new AudioCtx({ sampleRate });
          }
          if (playbackContext.state === "suspended") {
            await playbackContext.resume();
          }
          return playbackContext;
        }

        async function playPcm16Chunk(bytes) {
          if (!(bytes instanceof Uint8Array) || bytes.length < 2) {
            throw new Error("AudioOutput chunk is empty.");
          }
          const sampleRate = parseRate(els.playbackRate.value, DEFAULT_SAMPLE_RATE);
          const context = await ensurePlaybackContext(sampleRate);
          const samples = pcm16BytesToFloat32(bytes);
          const buffer = context.createBuffer(1, samples.length, sampleRate);
          buffer.getChannelData(0).set(samples);

          const source = context.createBufferSource();
          source.buffer = buffer;
          source.connect(context.destination);
          const startAt = Math.max(context.currentTime + 0.01, playbackCursor);
          source.start(startAt);
          playbackCursor = startAt + buffer.duration;
          setPlaybackStatus(`${voiceCounters.audioOutput} evt`);
        }

        function appendTranscript(text, isFinal) {
          if (!text) return;
          els.transcriptView.value += text;
          if (isFinal) {
            els.transcriptView.value += "\n";
          }
          els.transcriptView.scrollTop = els.transcriptView.scrollHeight;
        }

        function formatGraphReport(graph) {
          if (!graph || typeof graph !== "object") {
            return "No graph report.";
          }

          const lines = [];
          lines.push(`thread_id: ${graph.thread_id || "n/a"}`);
          lines.push(`completed: ${Boolean(graph.completed)}`);
          lines.push(`interrupted: ${Boolean(graph.interrupted)}`);

          const events = Array.isArray(graph.events) ? graph.events : [];
          lines.push(`events: ${events.length}`);
          for (const event of events) {
            const step = Number(event?.step || 0);
            const node = event?.node || "unknown";
            const action = event?.action || "event";
            const detail = event?.detail || "";
            lines.push(`- [step ${step}] ${node} :: ${action}${detail ? ` :: ${detail}` : ""}`);
          }

          lines.push("");
          lines.push("final_state:");
          lines.push(JSON.stringify(graph.final_state ?? {}, null, 2));
          return lines.join("\n");
        }

        async function sendFileAsAudioChunks() {
          if (!requireOpenSocket()) return;
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID required to send audio.");
            return;
          }

          const file = els.audioFile.files[0];
          if (!file) {
            log("error", "Select a file first.");
            return;
          }

          const chunkSize = Number(els.chunkSize.value) || 9600;
          const delayMs = Number(els.chunkDelay.value) || 0;
          const targetRate = parseRate(els.inputRate.value, DEFAULT_SAMPLE_RATE);

          if (chunkSize <= 0) {
            log("error", "Chunk size must be positive.");
            return;
          }

          els.audioProgress.textContent = "decode";
          const bytes = await decodeFileToPcm16(file, targetRate);
          const totalChunks = Math.max(1, Math.ceil(bytes.length / chunkSize));

          log(
            "system",
            `Streaming ${file.name} as PCM16 mono ${targetRate}Hz (${bytes.length} bytes) in ${totalChunks} chunk(s), chunk=${chunkSize}, delay=${delayMs}ms`
          );

          els.sendFileBtn.disabled = true;
          try {
            for (let idx = 0; idx < totalChunks; idx += 1) {
              const start = idx * chunkSize;
              const end = Math.min(start + chunkSize, bytes.length);
              const chunk = bytes.subarray(start, end);
              sendObject(
                {
                  type: "SessionAudio",
                  session_id: sid,
                  audio: bytesToBase64(chunk),
                },
                { silent: true }
              );
              els.audioProgress.textContent = `${idx + 1}/${totalChunks}`;
              if (delayMs > 0) await sleep(delayMs);
            }
            els.audioProgress.textContent = "done";
            log("system", "File audio stream completed.");
          } finally {
            els.sendFileBtn.disabled = false;
          }
        }

        async function startMicStream() {
          if (!requireOpenSocket()) return;
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Create or set a Session ID before starting mic stream.");
            setMicStatus("session required");
            refreshMicControls();
            return;
          }
          if (!AudioCtx) {
            log("error", "Web Audio API is not available in this browser.");
            setMicStatus("web-audio unavailable");
            return;
          }
          if (micState.active) {
            log("system", "Mic stream is already active.");
            return;
          }

          if (!window.isSecureContext) {
            throw new Error(
              "Microphone access requires secure context. Open the client via http://127.0.0.1:18080 or https (not file://)."
            );
          }

          setMicStatus("requesting permission");
          const stream = await requestMicrophoneStream({
            audio: {
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          const context = new AudioCtx();
          const source = context.createMediaStreamSource(stream);
          if (typeof context.createScriptProcessor !== "function") {
            stream.getTracks().forEach((track) => track.stop());
            await context.close().catch(() => {});
            throw new Error(
              "This browser does not support ScriptProcessor mic capture. Use Chrome or Edge for this client path."
            );
          }
          const processor = context.createScriptProcessor(MIC_BUFFER_SIZE, 1, 1);
          const sink = context.createGain();
          sink.gain.value = 0;

          processor.onaudioprocess = (event) => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const activeSid = activeSessionId();
            if (!activeSid) return;
            const targetRate = parseRate(els.inputRate.value, DEFAULT_SAMPLE_RATE);
            const mono = inputBufferToMono(event.inputBuffer);
            const resampled = resampleFloat32Linear(mono, context.sampleRate, targetRate);
            const pcmBytes = float32ToPcm16Bytes(resampled);
            if (pcmBytes.length === 0) return;
            sendObject(
              {
                type: "SessionAudio",
                session_id: activeSid,
                audio: bytesToBase64(pcmBytes),
              },
              { silent: true }
            );
          };

          source.connect(processor);
          processor.connect(sink);
          sink.connect(context.destination);

          micState.stream = stream;
          micState.context = context;
          micState.source = source;
          micState.processor = processor;
          micState.sink = sink;
          micState.active = true;
          refreshMicControls();
          setMicStatus(`live ${context.sampleRate}Hz`);
          log("system", `Mic streaming started for session ${sid}.`);
        }

        async function stopMicStream() {
          if (!micState.active) return;

          try {
            micState.processor?.disconnect();
            micState.source?.disconnect();
            micState.sink?.disconnect();
            micState.stream?.getTracks().forEach((track) => track.stop());
            await micState.context?.close();
          } catch (err) {
            log("error", `Failed to stop mic stream cleanly: ${err.message}`);
          } finally {
            micState.stream = null;
            micState.context = null;
            micState.source = null;
            micState.processor = null;
            micState.sink = null;
            micState.active = false;
            refreshMicControls();
            setMicStatus("idle");
            log("system", "Mic streaming stopped.");
          }
        }

        async function playLastOutput() {
          if (!lastAudioOutputBytes) {
            log("error", "No AudioOutput has been received yet.");
            return;
          }
          try {
            await playPcm16Chunk(lastAudioOutputBytes);
          } catch (err) {
            log("error", `Playback failed: ${err.message}`);
          }
        }

        function connect() {
          const url = els.wsUrl.value.trim();
          if (!url) {
            log("error", "Enter a WebSocket URL first.");
            return;
          }

          if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
            ws.close(1000, "Reconnect requested");
          }

          setStatus("connecting");
          refreshFlowControls();
          ws = new WebSocket(url);

          ws.onopen = () => {
            setStatus("connected");
            flowState.paired = false;
            flowState.authenticated = false;
            flowState.sessionReady = false;
            flowState.readySessionId = "";
            log("system", `Connected to ${url}`);
            savePrefs();
            refreshMicControls();
            refreshFlowControls();
            sendObject({ type: "GetGatewayHealth" }, { silent: true });
          };

          ws.onclose = async (event) => {
            const reason = event.reason || "no reason";
            setStatus("closed", `${event.code}`);
            resetFlowState();
            log("system", `Socket closed (${event.code}) - ${reason}`);
            await stopMicStream();
            refreshMicControls();
            refreshFlowControls();
          };

          ws.onerror = () => {
            setStatus("error");
            log("error", "WebSocket error.");
          };

          ws.onmessage = (event) => {
            const text = String(event.data);
            log("in", text);

            const parsed = parseJson(text);
            if (!parsed || typeof parsed !== "object") return;

            if (parsed.type === "PairSuccess" && parsed.token) {
              els.tokenInput.value = parsed.token;
              flowState.paired = true;
              flowState.authenticated = false;
              savePrefs();
              updateBadges();
              recordM4Snapshot("pair successful");
            }

            if (parsed.type === "PairFailure") {
              flowState.paired = false;
              flowState.authenticated = false;
              updateBadges();
              recordM4Snapshot("pair failed");
            }

            if (parsed.type === "Authenticated") {
              flowState.authenticated = true;
              if (flowState.requirePairing) {
                flowState.paired = true;
              }
              updateBadges();
              recordM4Snapshot("authenticated");
            }

            if (parsed.type === "SessionCreated" && parsed.session_id) {
              els.sessionId.value = parsed.session_id;
              flowState.sessionReady = true;
              flowState.readySessionId = parsed.session_id;
              savePrefs();
              updateBadges();
              resetSessionOutputState();
              recordM4Snapshot(`session created ${parsed.session_id}`);
            }

            if (parsed.type === "ChannelRouted" && parsed.session_id) {
              const routeMsg = `[${now()}] channel=${parsed.channel || "n/a"} account=${parsed.account_id || "n/a"} user=${parsed.external_user_id || "n/a"} -> session=${parsed.session_id}`;
              appendChannelRouteActivity(routeMsg);
              els.sessionId.value = parsed.session_id;
              flowState.sessionReady = true;
              flowState.readySessionId = parsed.session_id;
              savePrefs();
              updateBadges();
              recordM4Snapshot(`channel routed ${parsed.channel || "unknown"} -> ${parsed.session_id}`);
            }

            if (parsed.type === "ChannelOutboundBatch") {
              const channel = parsed.channel || "n/a";
              const accountId = parsed.account_id || "n/a";
              const externalUserId = parsed.external_user_id || "n/a";
              const items = Array.isArray(parsed.items) ? parsed.items : [];
              appendChannelOutboundActivity(
                `[${now()}] batch channel=${channel} account=${accountId} user=${externalUserId} count=${items.length}`
              );
              for (const item of items) {
                const sid = item?.session_id || "n/a";
                const text = item?.text || "";
                appendChannelOutboundActivity(`  - [${sid}] ${text}`);
              }
              recordM4Snapshot(`channel outbound batch ${channel} count=${items.length}`);
            }

            if (parsed.type === "SessionTerminated" && parsed.session_id) {
              if (parsed.session_id === activeSessionId() || parsed.session_id === flowState.readySessionId) {
                els.sessionId.value = "";
                flowState.sessionReady = false;
                flowState.readySessionId = "";
                savePrefs();
                updateBadges();
              }
              recordM4Snapshot(`session terminated ${parsed.session_id}`);
            }

            if (parsed.type === "Diagnostics" && parsed.data) {
              const d = parsed.data;
              m4State.lastDiagnostics = d;
              const compactions = Number(d.compactions_applied_total || 0);
              const reconnects = Number(d.reconnect_attempts_total || 0);
              const allowlistSize = Number(d.security_principal_allowlist_size || 0);
              const denyDefault = Boolean(d.security_deny_by_default_principal_allowlist);
              const publicBind = Boolean(d.security_allow_public_bind);
              els.diagBadge.textContent = `diag: rc=${reconnects} cp=${compactions}`;
              els.secBadge.textContent =
                `sec: deny=${denyDefault ? "on" : "off"} allow=${allowlistSize} bind=${publicBind ? "public" : "local"}`;
              if (d.security_workspace_root) {
                log(
                  "system",
                  `Diagnostics security: workspace=${d.security_workspace_root} forbidden=${(d.security_forbidden_tool_paths || []).join(",")}`
                );
              }
              syncTemplateOptions(d.supported_client_messages);
              recordM4Snapshot(
                `diagnostics reconnect_attempts=${reconnects} compactions=${compactions} active_sessions=${Number(d.active_sessions || 0)}`
              );
            }

            if (parsed.type === "GatewayHealth" && parsed.data) {
              const h = parsed.data;
              const pairing = h.require_pairing ? "pair" : "open";
              const up = Number(h.uptime_seconds || 0);
              const sessions = Number(h.active_sessions || 0);
              const p = Number(h.active_priority_bindings || 0);
              els.healthBadge.textContent = `gw: up=${up}s s=${sessions} p=${p} ${pairing}`;
              flowState.requirePairing = Boolean(h.require_pairing);
              if (!flowState.requirePairing) {
                flowState.paired = true;
                flowState.authenticated = true;
              }
              updateBadges();
              recordM4Snapshot(`gateway health require_pairing=${flowState.requirePairing}`);
            }

            if (parsed.type === "PriorityNotice" && parsed.data) {
              const p = parsed.data;
              const code = p.code || "notice";
              const level = p.level || "info";
              els.prioBadge.textContent = `prio: ${code} (${level})`;
            }

            if (parsed.type === "AudioAccepted" && parsed.session_id && parsed.session_id === activeSessionId()) {
              voiceCounters.accepted += 1;
              els.audioProgress.textContent = `ack ${voiceCounters.accepted}`;
            }

            if (parsed.type === "AudioCommitted" && parsed.session_id && parsed.session_id === activeSessionId()) {
              els.audioProgress.textContent = "committed";
            }

            if (
              parsed.type === "ResponseCreateAccepted" &&
              parsed.session_id &&
              parsed.session_id === activeSessionId()
            ) {
              els.audioProgress.textContent = "response requested";
            }

            if (
              parsed.type === "ResponseInterruptAccepted" &&
              parsed.session_id &&
              parsed.session_id === activeSessionId()
            ) {
              setPlaybackStatus("interrupted");
            }

            if (parsed.type === "PromptAccepted" && parsed.session_id && parsed.session_id === activeSessionId()) {
              els.audioProgress.textContent = "prompt accepted";
              appendPromptToolActivity(`[${now()}] prompt accepted for session ${parsed.session_id}`);
              recordM4Snapshot(`prompt accepted for session ${parsed.session_id}`);
            }

            if (parsed.type === "SessionToolResult" && parsed.session_id && parsed.session_id === activeSessionId()) {
              els.toolResultView.value = JSON.stringify(parsed.result ?? {}, null, 2);
              els.graphTraceView.value = formatGraphReport(parsed.graph);
              els.toolResultView.scrollTop = 0;
              els.graphTraceView.scrollTop = 0;
              appendPromptToolActivity(describeToolResultForActivity(parsed));
              m4State.toolResultCount += 1;
              m4State.lastToolSummary = summarizeToolResult(parsed);
              recordM4Snapshot(`tool result: ${m4State.lastToolSummary}`);
            }

            if (parsed.type === "TranscriptUpdate" && parsed.session_id && parsed.session_id === activeSessionId()) {
              voiceCounters.transcript += 1;
              const textChunk = parsed.text || "";
              m4State.transcriptChars += textChunk.length;
              appendTranscript(textChunk, Boolean(parsed.is_final));
              if (parsed.is_final) {
                recordM4Snapshot(`final transcript chunk observed (${textChunk.length} chars)`);
              } else {
                updateM4EvidenceView();
              }
            }

            if (parsed.type === "Error") {
              m4State.lastError = `${parsed.code || "unknown"}: ${parsed.message || "unknown"}`;
              appendPromptToolActivity(`[${now()}] error ${parsed.code || "unknown"}: ${parsed.message || "unknown"}`);
              if (parsed.code === "invalid_token" || parsed.code === "auth_required") {
                flowState.authenticated = false;
              }
              if (parsed.code === "invalid_pairing_code") {
                flowState.paired = false;
              }
              refreshFlowControls();
              recordM4Snapshot(`error ${parsed.code || "unknown"}`);
            }

            if (parsed.type === "AudioOutput" && parsed.session_id && parsed.session_id === activeSessionId()) {
              try {
                lastAudioOutputBytes = base64ToBytes(parsed.audio || "");
                voiceCounters.audioOutput += 1;
                setPlaybackStatus(`${voiceCounters.audioOutput} evt`);
                if (els.autoPlayOutput.checked) {
                  playPcm16Chunk(lastAudioOutputBytes).catch((err) => {
                    log("error", `Auto-play failed: ${err.message}`);
                  });
                }
              } catch (err) {
                log("error", `Failed to decode AudioOutput: ${err.message}`);
              }
            }
          };
        }

        function disconnect() {
          if (!ws) return;
          ws.close(1000, "Closed by user");
        }

        function buildCreateSessionMessage() {
          const cfg = {};
          const role = els.roleSelect.value;
          const model = els.modelInput.value.trim();
          const voice = els.voiceInput.value.trim();
          const graph = els.graphToggle.value;

          if (role) cfg.role = role;
          if (model) cfg.model = model;
          if (voice) cfg.voice = voice;
          if (graph === "true") cfg.enable_graph = true;
          if (graph === "false") cfg.enable_graph = false;

          return {
            type: "CreateSession",
            config: Object.keys(cfg).length > 0 ? cfg : null,
          };
        }

        els.connectBtn.addEventListener("click", () => {
          if (hasOpenSocket()) {
            disconnect();
          } else {
            connect();
          }
        });
        els.disconnectBtn.addEventListener("click", disconnect);

        els.pairBtn.addEventListener("click", () => {
          const code = els.pairCode.value.trim();
          if (!code) {
            log("error", "Pairing code is empty.");
            return;
          }
          flowState.paired = false;
          flowState.authenticated = false;
          refreshFlowControls();
          sendObject({ type: "Pair", code });
        });

        els.authBtn.addEventListener("click", () => {
          const token = els.tokenInput.value.trim();
          if (!token) {
            log("error", "Token is empty.");
            return;
          }
          flowState.authenticated = false;
          refreshFlowControls();
          sendObject({ type: "Authenticate", token });
          savePrefs();
          updateBadges();
        });

        els.createSessionBtn.addEventListener("click", () => {
          flowState.sessionReady = false;
          flowState.readySessionId = "";
          refreshFlowControls();
          sendObject(buildCreateSessionMessage());
        });

        els.pingBtn.addEventListener("click", () => {
          sendObject({ type: "Ping" });
        });

        els.healthBtn.addEventListener("click", () => {
          sendObject({ type: "GetGatewayHealth" });
        });

        els.priorityBtn.addEventListener("click", () => {
          sendObject({ type: "PriorityProbe" });
        });

        els.diagnosticsBtn.addEventListener("click", () => {
          sendObject({ type: "GetDiagnostics" });
        });

        els.terminateBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          sendObject({ type: "TerminateSession", session_id: sid });
          stopMicStream().catch((err) => {
            log("error", `Mic stop failed: ${err.message}`);
          });
        });

        els.sendB64Btn.addEventListener("click", () => {
          const sid = activeSessionId();
          const audio = els.audioB64.value.trim();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          if (!audio) {
            log("error", "Base64 audio payload is empty.");
            return;
          }
          sendObject({ type: "SessionAudio", session_id: sid, audio });
        });

        els.sendFileBtn.addEventListener("click", () => {
          sendFileAsAudioChunks().catch((err) => {
            els.audioProgress.textContent = "error";
            log("error", `Audio stream failed: ${err.message}`);
          });
        });

        els.micStartBtn.addEventListener("click", () => {
          startMicStream().catch((err) => {
            const message = err?.name === "NotAllowedError"
              ? "Microphone permission denied. Allow mic access for this page and retry."
              : (err?.message || String(err));
            setMicStatus("error");
            refreshMicControls();
            log("error", `Mic stream start failed: ${message}`);
          });
        });

        els.micStopBtn.addEventListener("click", () => {
          stopMicStream().catch((err) => {
            log("error", `Mic stream stop failed: ${err.message}`);
          });
        });

        els.playLastBtn.addEventListener("click", () => {
          playLastOutput().catch((err) => {
            log("error", `Playback failed: ${err.message}`);
          });
        });

        els.commitAudioBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          sendObject({ type: "SessionAudioCommit", session_id: sid });
        });

        els.createResponseBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          sendObject({ type: "SessionResponseCreate", session_id: sid });
        });

        els.interruptResponseBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          sendObject({ type: "SessionResponseInterrupt", session_id: sid });
        });

        function applyReadSummaryPrompt() {
          const prompt = buildReadSummaryPrompt(els.summaryFilePath.value, els.summaryBullets.value);
          els.promptInput.value = prompt;
          savePrefs();
          maybeApplyToolArgsPreset();
          return prompt;
        }

        els.applyReadSummaryPromptBtn.addEventListener("click", () => {
          const prompt = applyReadSummaryPrompt();
          appendPromptToolActivity(`[${now()}] prompt prepared: ${prompt}`);
        });

        els.runReadSummaryBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          const prompt = applyReadSummaryPrompt();
          els.transcriptView.value = "";
          els.toolResultView.value = "";
          els.graphTraceView.value = "";
          els.promptToolActivityView.value = "";
          sendObject({
            type: "SessionPrompt",
            session_id: sid,
            prompt,
            create_response: true,
          });
        });

        els.refreshM4Btn.addEventListener("click", () => {
          sendObject({ type: "GetDiagnostics" });
          recordM4Snapshot("requested diagnostics refresh");
        });

        els.captureM4Btn.addEventListener("click", () => {
          recordM4Snapshot("manual evidence snapshot");
        });

        function runReadWorkspaceProbe(path, probeLabel) {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          const trimmedPath = (path || "").trim();
          if (!trimmedPath) {
            log("error", `${probeLabel} path is empty.`);
            return;
          }
          const args = {
            path: trimmedPath,
            max_bytes: 4096,
          };
          els.toolName.value = "read_workspace_file";
          els.toolArgs.value = JSON.stringify(args, null, 2);
          sendObject({
            type: "SessionToolCall",
            session_id: sid,
            tool_name: "read_workspace_file",
            arguments: args,
          });
          recordM4Snapshot(`${probeLabel} probe requested for path '${trimmedPath}'`);
        }

        els.probeMemoryBtn.addEventListener("click", () => {
          runReadWorkspaceProbe(els.memoryProbePath.value, "memory");
        });

        els.probeArtifactBtn.addEventListener("click", () => {
          runReadWorkspaceProbe(els.artifactProbePath.value, "artifact");
        });

        els.routeChannelBtn.addEventListener("click", () => {
          const message = templateForType("ChannelInbound");
          if (!message.account_id || !message.external_user_id || !message.text) {
            log("error", "ChannelInbound requires account_id, external_user_id, and text.");
            return;
          }
          sendObject(message);
          savePrefs();
        });

        els.pollChannelOutboundBtn.addEventListener("click", () => {
          const message = templateForType("GetChannelOutbound");
          if (!message.account_id || !message.external_user_id) {
            log("error", "GetChannelOutbound requires account_id and external_user_id.");
            return;
          }
          sendObject(message);
          savePrefs();
        });

        els.sendPromptBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          const prompt = els.promptInput.value.trim();
          if (!prompt) {
            log("error", "Prompt is empty.");
            return;
          }
          sendObject({
            type: "SessionPrompt",
            session_id: sid,
            prompt,
            create_response: true,
          });
        });

        els.callToolBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          const toolName = els.toolName.value.trim();
          if (!toolName) {
            log("error", "Tool name is empty.");
            return;
          }
          const args = parseJson(els.toolArgs.value);
          if (args === null) {
            log("error", "Tool arguments must be valid JSON.");
            return;
          }
          sendObject({
            type: "SessionToolCall",
            session_id: sid,
            tool_name: toolName,
            arguments: args,
          });
        });

        els.toolName.addEventListener("change", () => {
          maybeApplyToolArgsPreset();
        });
        els.summaryFilePath.addEventListener("change", () => {
          maybeApplyToolArgsPreset();
        });

        els.sendRawBtn.addEventListener("click", () => {
          const obj = parseJson(els.rawJson.value);
          if (obj) sendObject(obj);
        });

        els.loadTemplateBtn.addEventListener("click", () => {
          const type = els.templateType.value;
          const template = templateForType(type);
          els.rawJson.value = JSON.stringify(template, null, 2);
        });

        els.rawJson.addEventListener("keydown", (event) => {
          if ((event.ctrlKey || event.metaKey) && event.key === "Enter") {
            event.preventDefault();
            els.sendRawBtn.click();
          }
        });

        els.clearLog.addEventListener("click", () => {
          els.log.innerHTML = "";
        });

        [
          els.wsUrl,
          els.tokenInput,
          els.sessionId,
          els.summaryFilePath,
          els.summaryBullets,
          els.memoryProbePath,
          els.artifactProbePath,
          els.channelType,
          els.channelAccountId,
          els.channelExternalUserId,
          els.channelOutboundMax,
        ].forEach((el) => {
          el.addEventListener("input", () => {
            savePrefs();
            updateBadges();
          });
          el.addEventListener("change", () => {
            savePrefs();
            updateBadges();
          });
        });
        [els.channelText, els.channelCreateResponse].forEach((el) => {
          el.addEventListener("input", savePrefs);
          el.addEventListener("change", savePrefs);
        });

        window.addEventListener("beforeunload", () => {
          stopMicStream().catch(() => {});
        });

        resetFlowState();
        loadPrefs();
        setStatus("closed");
        setMicStatus("idle");
        setPlaybackStatus("idle");
        refreshMicControls();
        refreshFlowControls();
        maybeApplyToolArgsPreset();
        if (!window.isSecureContext) {
          log(
            "error",
            "Page is not in a secure context. Mic access requires http://127.0.0.1 or https."
          );
        }
        if (!navigator.mediaDevices?.getUserMedia && !legacyGetUserMediaFn()) {
          log(
            "error",
            "Microphone API is unavailable in this browser. Use recent Chrome/Edge/Safari."
          );
        }
        log("system", "Ready. Connect, Pair/Auth, then CreateSession.");
      })();
    </script>
  </body>
</html>
