<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>LiveClaw WS Client</title>
    <style>
      :root {
        --bg: #f2efe8;
        --panel: #fffdf8;
        --ink: #1c1f2a;
        --muted: #5f6677;
        --line: #d9d2c4;
        --accent: #007f6f;
        --accent-soft: #d9f3ef;
        --warn: #b54b3a;
        --ok: #2f6f45;
        --out: #0a4b8f;
        --in: #264025;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        min-height: 100vh;
        font-family: "IBM Plex Sans", "Avenir Next", "Helvetica Neue", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 10% -10%, #d0ebe5 0%, transparent 35%),
          radial-gradient(circle at 90% 0%, #ffdcb8 0%, transparent 30%),
          linear-gradient(160deg, #f7f4ed 0%, #ece6d9 100%);
      }

      .shell {
        max-width: 1200px;
        margin: 0 auto;
        padding: 24px 18px 36px;
      }

      .hero {
        display: grid;
        gap: 6px;
        margin-bottom: 14px;
      }

      .title {
        font-size: clamp(1.4rem, 2.4vw, 2rem);
        margin: 0;
        letter-spacing: 0.02em;
      }

      .subtitle {
        margin: 0;
        color: var(--muted);
        font-size: 0.95rem;
      }

      .card {
        border: 1px solid var(--line);
        background: var(--panel);
        border-radius: 12px;
        box-shadow: 0 8px 26px rgba(38, 32, 20, 0.07);
      }

      .status-bar {
        display: grid;
        grid-template-columns: 1fr auto auto auto auto auto auto auto;
        gap: 10px;
        align-items: center;
        padding: 14px;
        margin-bottom: 12px;
      }

      .status-pill {
        justify-self: start;
        border-radius: 999px;
        padding: 6px 12px;
        font-weight: 600;
        font-size: 0.85rem;
        border: 1px solid transparent;
        background: #eceaf2;
      }

      .status-pill.connected {
        color: var(--ok);
        background: #dff2e6;
        border-color: #b8ddc7;
      }

      .status-pill.connecting {
        color: #7a5b00;
        background: #fff2cc;
        border-color: #e3c66f;
      }

      .status-pill.closed,
      .status-pill.error {
        color: var(--warn);
        background: #f8dfdc;
        border-color: #e8b9b2;
      }

      .layout {
        display: grid;
        grid-template-columns: repeat(12, minmax(0, 1fr));
        gap: 12px;
      }

      .span-6 {
        grid-column: span 6;
      }

      .span-12 {
        grid-column: span 12;
      }

      h2 {
        margin: 0 0 12px;
        font-size: 1rem;
      }

      .panel {
        padding: 14px;
      }

      .field-grid {
        display: grid;
        gap: 10px;
      }

      .field-row {
        display: grid;
        gap: 8px;
        grid-template-columns: 1fr auto;
      }

      .field-row.compact {
        grid-template-columns: repeat(2, 1fr);
      }

      .field-row.triple {
        grid-template-columns: repeat(3, 1fr);
      }

      .field-stack {
        display: grid;
        gap: 6px;
      }

      label {
        font-size: 0.83rem;
        color: var(--muted);
      }

      input,
      select,
      textarea,
      button {
        font: inherit;
      }

      input,
      select,
      textarea {
        width: 100%;
        border: 1px solid #cfc7b9;
        background: #fff;
        border-radius: 9px;
        padding: 9px 10px;
        color: var(--ink);
      }

      textarea {
        min-height: 130px;
        resize: vertical;
        font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
        font-size: 0.88rem;
      }

      button {
        border: 1px solid transparent;
        border-radius: 9px;
        padding: 8px 12px;
        cursor: pointer;
        font-weight: 600;
      }

      button.primary {
        background: var(--accent);
        color: #fff;
      }

      button.primary:hover {
        filter: brightness(1.05);
      }

      button.soft {
        background: var(--accent-soft);
        color: #175950;
      }

      button.muted {
        background: #ede6db;
        color: #534f45;
      }

      button.warn {
        background: #f6dfdc;
        color: #7f2d22;
      }

      button:disabled {
        cursor: not-allowed;
        opacity: 0.58;
      }

      .hint {
        margin: 4px 0 0;
        color: var(--muted);
        font-size: 0.8rem;
      }

      .log {
        background: #1b1c23;
        color: #e9ecf3;
        border-radius: 10px;
        padding: 12px;
        min-height: 260px;
        max-height: 44vh;
        overflow: auto;
        font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
        font-size: 0.82rem;
        line-height: 1.45;
      }

      .line {
        margin: 0 0 6px;
        white-space: pre-wrap;
        word-break: break-word;
      }

      .line.system {
        color: #d4d0f6;
      }

      .line.out {
        color: #9fc9ff;
      }

      .line.in {
        color: #b2f0c4;
      }

      .line.error {
        color: #ffc2ba;
      }

      .badge {
        padding: 5px 10px;
        border: 1px solid #d5cdbf;
        border-radius: 999px;
        font-size: 0.8rem;
        background: #f5f2ea;
      }

      .inline-check {
        display: flex;
        gap: 8px;
        align-items: center;
        color: var(--muted);
        font-size: 0.85rem;
      }

      .inline-check input[type="checkbox"] {
        width: auto;
      }

      .output-pane {
        min-height: 100px;
        max-height: 160px;
        overflow: auto;
        font-family: "JetBrains Mono", "Menlo", "Consolas", monospace;
        font-size: 0.84rem;
      }

      @media (max-width: 920px) {
        .status-bar {
          grid-template-columns: 1fr;
        }

        .span-6 {
          grid-column: span 12;
        }

        .field-row,
        .field-row.compact,
        .field-row.triple {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <main class="shell">
      <header class="hero">
        <h1 class="title">LiveClaw Browser WebSocket Client</h1>
        <p class="subtitle">
          Reusable control and audio test console for pairing, session lifecycle, and SessionAudio traffic.
        </p>
      </header>

      <section class="card status-bar">
        <span id="statusPill" class="status-pill closed">closed</span>
        <span class="badge" id="sessionBadge">session: none</span>
        <span class="badge" id="tokenBadge">token: none</span>
        <span class="badge" id="diagBadge">diag: n/a</span>
        <span class="badge" id="secBadge">sec: n/a</span>
        <span class="badge" id="healthBadge">gw: n/a</span>
        <span class="badge" id="prioBadge">prio: n/a</span>
        <button id="clearLog" class="muted">Clear Log</button>
      </section>

      <section class="layout">
        <article class="card panel span-6">
          <h2>Connection and Session</h2>
          <div class="field-grid">
            <div class="field-row">
              <div class="field-stack">
                <label for="wsUrl">WebSocket URL</label>
                <input id="wsUrl" value="ws://127.0.0.1:8420/ws" />
              </div>
              <button id="connectBtn" class="primary">Connect</button>
            </div>
            <div class="field-row">
              <div class="field-stack">
                <label for="pairCode">Pairing Code</label>
                <input id="pairCode" placeholder="e.g. 755810" />
              </div>
              <button id="pairBtn" class="soft">Send Pair</button>
            </div>
            <div class="field-row">
              <div class="field-stack">
                <label for="tokenInput">Token</label>
                <input id="tokenInput" placeholder="auto-filled from PairSuccess" />
              </div>
              <button id="authBtn" class="soft">Authenticate</button>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="roleSelect">Role</label>
                <select id="roleSelect">
                  <option value="">(default)</option>
                  <option value="readonly">readonly</option>
                  <option value="supervised">supervised</option>
                  <option value="full">full</option>
                </select>
              </div>
              <div class="field-stack">
                <label for="graphToggle">Enable Graph</label>
                <select id="graphToggle">
                  <option value="">(default)</option>
                  <option value="true">true</option>
                  <option value="false">false</option>
                </select>
              </div>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="modelInput">Model (optional)</label>
                <input id="modelInput" placeholder="e.g. gpt-4o-realtime-preview" />
              </div>
              <div class="field-stack">
                <label for="voiceInput">Voice (optional)</label>
                <input id="voiceInput" placeholder="e.g. alloy" />
              </div>
            </div>
            <div class="field-row">
              <div class="field-stack">
                <label for="sessionId">Session ID</label>
                <input id="sessionId" placeholder="auto-filled from SessionCreated" />
              </div>
              <button id="createSessionBtn" class="primary">Create Session</button>
            </div>
            <div class="field-row">
              <button id="pingBtn" class="muted">Ping</button>
              <button id="healthBtn" class="muted">Gateway Health</button>
              <button id="priorityBtn" class="soft">Priority Probe</button>
              <button id="diagnosticsBtn" class="soft">Get Diagnostics</button>
              <button id="terminateBtn" class="warn">Terminate Session</button>
            </div>
          </div>
        </article>

        <article class="card panel span-6">
          <h2>Audio Test</h2>
          <div class="field-grid">
            <div class="field-row">
              <div class="field-stack">
                <label for="audioB64">Single Chunk Base64 Audio</label>
                <input id="audioB64" value="AQID" />
              </div>
              <button id="sendB64Btn" class="soft">Send Chunk</button>
            </div>
            <div class="field-stack">
              <label for="audioFile">Upload Audio/PCM File</label>
              <input id="audioFile" type="file" />
            </div>
            <div class="field-row triple">
              <div class="field-stack">
                <label for="chunkSize">Chunk Bytes</label>
                <input id="chunkSize" type="number" min="256" step="256" value="9600" />
              </div>
              <div class="field-stack">
                <label for="chunkDelay">Delay ms</label>
                <input id="chunkDelay" type="number" min="0" step="10" value="120" />
              </div>
              <div class="field-stack">
                <label for="inputRate">Input Sample Rate (Hz)</label>
                <input id="inputRate" type="number" min="8000" step="1000" value="24000" />
              </div>
            </div>
            <div class="field-row compact">
              <div class="field-stack">
                <label for="playbackRate">Output Sample Rate (Hz)</label>
                <input id="playbackRate" type="number" min="8000" step="1000" value="24000" />
              </div>
              <div class="field-stack">
                <label for="autoPlayOutput">Playback</label>
                <label class="inline-check">
                  <input id="autoPlayOutput" type="checkbox" checked />
                  Auto-play AudioOutput
                </label>
              </div>
            </div>
            <div class="field-row">
              <button id="sendFileBtn" class="primary">Send File as SessionAudio Chunks</button>
              <span id="audioProgress" class="badge">idle</span>
            </div>
            <div class="field-row triple">
              <button id="micStartBtn" class="soft">Start Mic Stream</button>
              <button id="micStopBtn" class="warn" disabled>Stop Mic Stream</button>
              <button id="playLastBtn" class="muted">Play Last Output</button>
            </div>
            <div class="field-row compact">
              <span id="micStatus" class="badge">mic: idle</span>
              <span id="playbackStatus" class="badge">play: idle</span>
            </div>
            <div class="field-row triple">
              <button id="commitAudioBtn" class="muted">Commit Audio</button>
              <button id="createResponseBtn" class="soft">Create Response</button>
              <button id="interruptResponseBtn" class="warn">Interrupt Response</button>
            </div>
            <div class="field-stack">
              <label for="transcriptView">Session Transcript View</label>
              <textarea
                id="transcriptView"
                class="output-pane"
                readonly
                placeholder="TranscriptUpdate deltas for the active session appear here."
              ></textarea>
            </div>
            <p class="hint">
              Upload accepts common browser-decodable audio and converts to PCM16 mono. For raw files, use .pcm.
            </p>
          </div>
        </article>

        <article class="card panel span-6">
          <h2>Tool + Graph (M3)</h2>
          <div class="field-grid">
            <div class="field-row compact">
              <div class="field-stack">
                <label for="toolName">Tool Name</label>
                <select id="toolName">
                  <option value="echo_text">echo_text</option>
                  <option value="add_numbers">add_numbers</option>
                  <option value="utc_time">utc_time</option>
                  <option value="read_workspace_file">read_workspace_file</option>
                </select>
              </div>
              <div class="field-stack">
                <label>&nbsp;</label>
                <button id="callToolBtn" class="primary">SessionToolCall</button>
              </div>
            </div>
            <div class="field-stack">
              <label for="toolArgs">Tool Arguments (JSON)</label>
              <textarea id="toolArgs" class="output-pane" spellcheck="false">{
  "text": "hello from graph"
}</textarea>
            </div>
            <div class="field-stack">
              <label for="toolResultView">Tool Result</label>
              <textarea id="toolResultView" class="output-pane" readonly></textarea>
            </div>
            <div class="field-stack">
              <label for="graphTraceView">Graph Trace</label>
              <textarea id="graphTraceView" class="output-pane" readonly></textarea>
            </div>
            <p class="hint">
              For graph execution, create session with role `full` and `Enable Graph = true`.
            </p>
          </div>
        </article>

        <article class="card panel span-12">
          <h2>Raw JSON Message</h2>
          <div class="field-grid">
            <div class="field-row compact">
              <div class="field-stack">
                <label for="templateType">Message Template</label>
                <select id="templateType">
                  <option value="Ping">Ping</option>
                  <option value="GetGatewayHealth">GetGatewayHealth</option>
                  <option value="PriorityProbe">PriorityProbe</option>
                  <option value="GetDiagnostics">GetDiagnostics</option>
                  <option value="CreateSession">CreateSession</option>
                  <option value="TerminateSession">TerminateSession</option>
                  <option value="SessionAudio">SessionAudio</option>
                  <option value="SessionAudioCommit">SessionAudioCommit</option>
                  <option value="SessionResponseCreate">SessionResponseCreate</option>
                  <option value="SessionResponseInterrupt">SessionResponseInterrupt</option>
                  <option value="SessionToolCall">SessionToolCall</option>
                </select>
              </div>
              <div class="field-stack">
                <label>&nbsp;</label>
                <button id="loadTemplateBtn" class="soft">Load Template</button>
              </div>
            </div>
            <textarea id="rawJson" spellcheck="false">{"type":"Ping"}</textarea>
            <div class="field-row">
              <button id="sendRawBtn" class="primary">Send JSON</button>
              <button id="disconnectBtn" class="muted">Disconnect</button>
            </div>
          </div>
        </article>

        <article class="card panel span-12">
          <h2>Traffic Log</h2>
          <div id="log" class="log" aria-live="polite"></div>
        </article>
      </section>
    </main>

    <script>
      (() => {
        const $ = (id) => document.getElementById(id);

        const els = {
          statusPill: $("statusPill"),
          sessionBadge: $("sessionBadge"),
          tokenBadge: $("tokenBadge"),
          diagBadge: $("diagBadge"),
          secBadge: $("secBadge"),
          healthBadge: $("healthBadge"),
          prioBadge: $("prioBadge"),
          wsUrl: $("wsUrl"),
          connectBtn: $("connectBtn"),
          disconnectBtn: $("disconnectBtn"),
          clearLog: $("clearLog"),
          pairCode: $("pairCode"),
          pairBtn: $("pairBtn"),
          tokenInput: $("tokenInput"),
          authBtn: $("authBtn"),
          roleSelect: $("roleSelect"),
          graphToggle: $("graphToggle"),
          modelInput: $("modelInput"),
          voiceInput: $("voiceInput"),
          createSessionBtn: $("createSessionBtn"),
          sessionId: $("sessionId"),
          pingBtn: $("pingBtn"),
          healthBtn: $("healthBtn"),
          priorityBtn: $("priorityBtn"),
          diagnosticsBtn: $("diagnosticsBtn"),
          terminateBtn: $("terminateBtn"),
          audioB64: $("audioB64"),
          sendB64Btn: $("sendB64Btn"),
          audioFile: $("audioFile"),
          chunkSize: $("chunkSize"),
          chunkDelay: $("chunkDelay"),
          inputRate: $("inputRate"),
          playbackRate: $("playbackRate"),
          autoPlayOutput: $("autoPlayOutput"),
          sendFileBtn: $("sendFileBtn"),
          audioProgress: $("audioProgress"),
          micStartBtn: $("micStartBtn"),
          micStopBtn: $("micStopBtn"),
          micStatus: $("micStatus"),
          playLastBtn: $("playLastBtn"),
          playbackStatus: $("playbackStatus"),
          commitAudioBtn: $("commitAudioBtn"),
          createResponseBtn: $("createResponseBtn"),
          interruptResponseBtn: $("interruptResponseBtn"),
          transcriptView: $("transcriptView"),
          toolName: $("toolName"),
          toolArgs: $("toolArgs"),
          callToolBtn: $("callToolBtn"),
          toolResultView: $("toolResultView"),
          graphTraceView: $("graphTraceView"),
          rawJson: $("rawJson"),
          sendRawBtn: $("sendRawBtn"),
          templateType: $("templateType"),
          loadTemplateBtn: $("loadTemplateBtn"),
          log: $("log"),
        };

        const keys = {
          wsUrl: "liveclaw.ws.url",
          token: "liveclaw.ws.token",
          sessionId: "liveclaw.ws.session_id",
        };

        const DEFAULT_SAMPLE_RATE = 24000;
        const MIC_BUFFER_SIZE = 4096;
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        const OfflineCtx = window.OfflineAudioContext || window.webkitOfflineAudioContext;

        let ws = null;
        let playbackContext = null;
        let playbackCursor = 0;
        let lastAudioOutputBytes = null;
        const voiceCounters = {
          accepted: 0,
          transcript: 0,
          audioOutput: 0,
        };

        const micState = {
          stream: null,
          context: null,
          source: null,
          processor: null,
          sink: null,
          active: false,
        };

        const now = () => new Date().toLocaleTimeString();
        const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

        function log(kind, text) {
          const line = document.createElement("div");
          line.className = `line ${kind}`;
          line.textContent = `[${now()}] ${text}`;
          els.log.appendChild(line);
          els.log.scrollTop = els.log.scrollHeight;
        }

        function setStatus(state, details = "") {
          els.statusPill.className = `status-pill ${state}`;
          els.statusPill.textContent = details ? `${state} - ${details}` : state;
        }

        function setMicStatus(text) {
          els.micStatus.textContent = `mic: ${text}`;
        }

        function setPlaybackStatus(text) {
          els.playbackStatus.textContent = `play: ${text}`;
        }

        function parseRate(value, fallback) {
          const num = Number(value);
          if (!Number.isFinite(num) || num <= 0) return fallback;
          return Math.floor(num);
        }

        function activeSessionId() {
          return els.sessionId.value.trim();
        }

        function updateBadges() {
          const sid = activeSessionId();
          const tok = els.tokenInput.value.trim();
          els.sessionBadge.textContent = sid ? `session: ${sid}` : "session: none";
          els.tokenBadge.textContent = tok ? `token: ${tok.slice(0, 12)}...` : "token: none";
        }

        function resetSessionOutputState() {
          voiceCounters.accepted = 0;
          voiceCounters.transcript = 0;
          voiceCounters.audioOutput = 0;
          lastAudioOutputBytes = null;
          els.transcriptView.value = "";
          els.toolResultView.value = "";
          els.graphTraceView.value = "";
          els.audioProgress.textContent = "idle";
          setPlaybackStatus("idle");
        }

        function savePrefs() {
          localStorage.setItem(keys.wsUrl, els.wsUrl.value.trim());
          localStorage.setItem(keys.token, els.tokenInput.value.trim());
          localStorage.setItem(keys.sessionId, activeSessionId());
        }

        function loadPrefs() {
          const url = localStorage.getItem(keys.wsUrl);
          const token = localStorage.getItem(keys.token);
          const sid = localStorage.getItem(keys.sessionId);
          if (url) els.wsUrl.value = url;
          if (token) els.tokenInput.value = token;
          if (sid) els.sessionId.value = sid;
          updateBadges();
        }

        function requireOpenSocket() {
          if (!ws || ws.readyState !== WebSocket.OPEN) {
            log("error", "Socket is not open. Connect first.");
            return false;
          }
          return true;
        }

        function sendObject(message, options = {}) {
          if (!requireOpenSocket()) return false;
          const serialized = JSON.stringify(message);
          ws.send(serialized);
          if (!options.silent) {
            log("out", serialized);
          }
          return true;
        }

        function parseJson(text) {
          try {
            return JSON.parse(text);
          } catch (err) {
            log("error", `Invalid JSON: ${err.message}`);
            return null;
          }
        }

        function syncTemplateOptions(types) {
          if (!Array.isArray(types) || types.length === 0) return;
          const prev = els.templateType.value;
          els.templateType.innerHTML = "";
          for (const t of types) {
            const opt = document.createElement("option");
            opt.value = t;
            opt.textContent = t;
            els.templateType.appendChild(opt);
          }
          if ([...types].includes(prev)) {
            els.templateType.value = prev;
          }
        }

        function templateForType(type) {
          const sid = activeSessionId() || "<SESSION_ID>";
          const token = els.tokenInput.value.trim() || "<TOKEN>";
          const code = els.pairCode.value.trim() || "<PAIRING_CODE>";
          switch (type) {
            case "Pair":
              return { type: "Pair", code };
            case "Authenticate":
              return { type: "Authenticate", token };
            case "CreateSession":
              return buildCreateSessionMessage();
            case "TerminateSession":
              return { type: "TerminateSession", session_id: sid };
            case "SessionAudio":
              return {
                type: "SessionAudio",
                session_id: sid,
                audio: els.audioB64.value.trim() || "AQID",
              };
            case "SessionAudioCommit":
              return { type: "SessionAudioCommit", session_id: sid };
            case "SessionResponseCreate":
              return { type: "SessionResponseCreate", session_id: sid };
            case "SessionResponseInterrupt":
              return { type: "SessionResponseInterrupt", session_id: sid };
            case "SessionToolCall": {
              const toolName = els.toolName.value.trim() || "echo_text";
              const parsedArgs = parseJson(els.toolArgs.value) || { text: "hello from graph" };
              return {
                type: "SessionToolCall",
                session_id: sid,
                tool_name: toolName,
                arguments: parsedArgs,
              };
            }
            case "GetDiagnostics":
              return { type: "GetDiagnostics" };
            case "GetGatewayHealth":
              return { type: "GetGatewayHealth" };
            case "PriorityProbe":
              return { type: "PriorityProbe" };
            case "Ping":
            default:
              return { type: "Ping" };
          }
        }

        function bytesToBase64(bytes) {
          let binary = "";
          for (let i = 0; i < bytes.length; i += 1) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        }

        function base64ToBytes(audioB64) {
          const binary = atob(audioB64);
          const out = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i += 1) {
            out[i] = binary.charCodeAt(i);
          }
          return out;
        }

        function float32ToPcm16Bytes(samples) {
          const out = new Uint8Array(samples.length * 2);
          for (let i = 0; i < samples.length; i += 1) {
            const sample = Math.max(-1, Math.min(1, samples[i]));
            const value = sample < 0 ? Math.round(sample * 0x8000) : Math.round(sample * 0x7fff);
            out[i * 2] = value & 0xff;
            out[i * 2 + 1] = (value >> 8) & 0xff;
          }
          return out;
        }

        function pcm16BytesToFloat32(bytes) {
          const sampleCount = Math.floor(bytes.length / 2);
          const out = new Float32Array(sampleCount);
          for (let i = 0; i < sampleCount; i += 1) {
            const lo = bytes[i * 2];
            const hi = bytes[i * 2 + 1];
            let sample = (hi << 8) | lo;
            if (sample & 0x8000) sample -= 0x10000;
            out[i] = sample / 32768;
          }
          return out;
        }

        function resampleFloat32Linear(samples, sourceRate, targetRate) {
          if (sourceRate === targetRate) {
            return samples;
          }
          const ratio = sourceRate / targetRate;
          const outLength = Math.max(1, Math.round(samples.length / ratio));
          const out = new Float32Array(outLength);
          for (let i = 0; i < outLength; i += 1) {
            const sourceIndex = i * ratio;
            const low = Math.floor(sourceIndex);
            const high = Math.min(low + 1, samples.length - 1);
            const weight = sourceIndex - low;
            out[i] = samples[low] * (1 - weight) + samples[high] * weight;
          }
          return out;
        }

        function inputBufferToMono(inputBuffer) {
          if (inputBuffer.numberOfChannels <= 1) {
            return new Float32Array(inputBuffer.getChannelData(0));
          }
          const mono = new Float32Array(inputBuffer.length);
          for (let c = 0; c < inputBuffer.numberOfChannels; c += 1) {
            const channel = inputBuffer.getChannelData(c);
            for (let i = 0; i < inputBuffer.length; i += 1) {
              mono[i] += channel[i];
            }
          }
          for (let i = 0; i < mono.length; i += 1) {
            mono[i] /= inputBuffer.numberOfChannels;
          }
          return mono;
        }

        function isRawPcmFile(file) {
          const name = (file?.name || "").toLowerCase();
          return name.endsWith(".pcm") || name.endsWith(".raw") || name.endsWith(".s16le");
        }

        async function decodeFileToPcm16(file, targetRate) {
          if (isRawPcmFile(file)) {
            return new Uint8Array(await file.arrayBuffer());
          }

          if (!AudioCtx || !OfflineCtx) {
            throw new Error("Web Audio API is not available in this browser.");
          }

          const decodeContext = new AudioCtx();
          try {
            const inputBuffer = await file.arrayBuffer();
            const decoded = await decodeContext.decodeAudioData(inputBuffer.slice(0));
            const frameCount = Math.max(1, Math.ceil(decoded.duration * targetRate));
            const offline = new OfflineCtx(1, frameCount, targetRate);
            const source = offline.createBufferSource();
            source.buffer = decoded;
            source.connect(offline.destination);
            source.start(0);
            const rendered = await offline.startRendering();
            return float32ToPcm16Bytes(rendered.getChannelData(0));
          } finally {
            decodeContext.close().catch(() => {});
          }
        }

        async function ensurePlaybackContext(sampleRate) {
          if (!AudioCtx) {
            throw new Error("Audio playback is not supported in this browser.");
          }
          if (!playbackContext) {
            playbackContext = new AudioCtx({ sampleRate });
          }
          if (playbackContext.state === "suspended") {
            await playbackContext.resume();
          }
          return playbackContext;
        }

        async function playPcm16Chunk(bytes) {
          if (!(bytes instanceof Uint8Array) || bytes.length < 2) {
            throw new Error("AudioOutput chunk is empty.");
          }
          const sampleRate = parseRate(els.playbackRate.value, DEFAULT_SAMPLE_RATE);
          const context = await ensurePlaybackContext(sampleRate);
          const samples = pcm16BytesToFloat32(bytes);
          const buffer = context.createBuffer(1, samples.length, sampleRate);
          buffer.getChannelData(0).set(samples);

          const source = context.createBufferSource();
          source.buffer = buffer;
          source.connect(context.destination);
          const startAt = Math.max(context.currentTime + 0.01, playbackCursor);
          source.start(startAt);
          playbackCursor = startAt + buffer.duration;
          setPlaybackStatus(`${voiceCounters.audioOutput} evt`);
        }

        function appendTranscript(text, isFinal) {
          if (!text) return;
          els.transcriptView.value += text;
          if (isFinal) {
            els.transcriptView.value += "\n";
          }
          els.transcriptView.scrollTop = els.transcriptView.scrollHeight;
        }

        function formatGraphReport(graph) {
          if (!graph || typeof graph !== "object") {
            return "No graph report.";
          }

          const lines = [];
          lines.push(`thread_id: ${graph.thread_id || "n/a"}`);
          lines.push(`completed: ${Boolean(graph.completed)}`);
          lines.push(`interrupted: ${Boolean(graph.interrupted)}`);

          const events = Array.isArray(graph.events) ? graph.events : [];
          lines.push(`events: ${events.length}`);
          for (const event of events) {
            const step = Number(event?.step || 0);
            const node = event?.node || "unknown";
            const action = event?.action || "event";
            const detail = event?.detail || "";
            lines.push(`- [step ${step}] ${node} :: ${action}${detail ? ` :: ${detail}` : ""}`);
          }

          lines.push("");
          lines.push("final_state:");
          lines.push(JSON.stringify(graph.final_state ?? {}, null, 2));
          return lines.join("\n");
        }

        async function sendFileAsAudioChunks() {
          if (!requireOpenSocket()) return;
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID required to send audio.");
            return;
          }

          const file = els.audioFile.files[0];
          if (!file) {
            log("error", "Select a file first.");
            return;
          }

          const chunkSize = Number(els.chunkSize.value) || 9600;
          const delayMs = Number(els.chunkDelay.value) || 0;
          const targetRate = parseRate(els.inputRate.value, DEFAULT_SAMPLE_RATE);

          if (chunkSize <= 0) {
            log("error", "Chunk size must be positive.");
            return;
          }

          els.audioProgress.textContent = "decode";
          const bytes = await decodeFileToPcm16(file, targetRate);
          const totalChunks = Math.max(1, Math.ceil(bytes.length / chunkSize));

          log(
            "system",
            `Streaming ${file.name} as PCM16 mono ${targetRate}Hz (${bytes.length} bytes) in ${totalChunks} chunk(s), chunk=${chunkSize}, delay=${delayMs}ms`
          );

          els.sendFileBtn.disabled = true;
          try {
            for (let idx = 0; idx < totalChunks; idx += 1) {
              const start = idx * chunkSize;
              const end = Math.min(start + chunkSize, bytes.length);
              const chunk = bytes.subarray(start, end);
              sendObject(
                {
                  type: "SessionAudio",
                  session_id: sid,
                  audio: bytesToBase64(chunk),
                },
                { silent: true }
              );
              els.audioProgress.textContent = `${idx + 1}/${totalChunks}`;
              if (delayMs > 0) await sleep(delayMs);
            }
            els.audioProgress.textContent = "done";
            log("system", "File audio stream completed.");
          } finally {
            els.sendFileBtn.disabled = false;
          }
        }

        async function startMicStream() {
          if (!requireOpenSocket()) return;
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Create or set a Session ID before starting mic stream.");
            return;
          }
          if (!navigator.mediaDevices?.getUserMedia) {
            log("error", "getUserMedia is not available in this browser.");
            return;
          }
          if (!AudioCtx) {
            log("error", "Web Audio API is not available in this browser.");
            return;
          }
          if (micState.active) {
            log("system", "Mic stream is already active.");
            return;
          }

          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              channelCount: 1,
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true,
            },
          });

          const context = new AudioCtx();
          const source = context.createMediaStreamSource(stream);
          const processor = context.createScriptProcessor(MIC_BUFFER_SIZE, 1, 1);
          const sink = context.createGain();
          sink.gain.value = 0;

          processor.onaudioprocess = (event) => {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            const activeSid = activeSessionId();
            if (!activeSid) return;
            const targetRate = parseRate(els.inputRate.value, DEFAULT_SAMPLE_RATE);
            const mono = inputBufferToMono(event.inputBuffer);
            const resampled = resampleFloat32Linear(mono, context.sampleRate, targetRate);
            const pcmBytes = float32ToPcm16Bytes(resampled);
            if (pcmBytes.length === 0) return;
            sendObject(
              {
                type: "SessionAudio",
                session_id: activeSid,
                audio: bytesToBase64(pcmBytes),
              },
              { silent: true }
            );
          };

          source.connect(processor);
          processor.connect(sink);
          sink.connect(context.destination);

          micState.stream = stream;
          micState.context = context;
          micState.source = source;
          micState.processor = processor;
          micState.sink = sink;
          micState.active = true;
          els.micStartBtn.disabled = true;
          els.micStopBtn.disabled = false;
          setMicStatus(`live ${context.sampleRate}Hz`);
          log("system", `Mic streaming started for session ${sid}.`);
        }

        async function stopMicStream() {
          if (!micState.active) return;

          try {
            micState.processor?.disconnect();
            micState.source?.disconnect();
            micState.sink?.disconnect();
            micState.stream?.getTracks().forEach((track) => track.stop());
            await micState.context?.close();
          } catch (err) {
            log("error", `Failed to stop mic stream cleanly: ${err.message}`);
          } finally {
            micState.stream = null;
            micState.context = null;
            micState.source = null;
            micState.processor = null;
            micState.sink = null;
            micState.active = false;
            els.micStartBtn.disabled = false;
            els.micStopBtn.disabled = true;
            setMicStatus("idle");
            log("system", "Mic streaming stopped.");
          }
        }

        async function playLastOutput() {
          if (!lastAudioOutputBytes) {
            log("error", "No AudioOutput has been received yet.");
            return;
          }
          try {
            await playPcm16Chunk(lastAudioOutputBytes);
          } catch (err) {
            log("error", `Playback failed: ${err.message}`);
          }
        }

        function connect() {
          const url = els.wsUrl.value.trim();
          if (!url) {
            log("error", "Enter a WebSocket URL first.");
            return;
          }

          if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
            ws.close(1000, "Reconnect requested");
          }

          setStatus("connecting");
          ws = new WebSocket(url);

          ws.onopen = () => {
            setStatus("connected");
            log("system", `Connected to ${url}`);
            savePrefs();
          };

          ws.onclose = async (event) => {
            const reason = event.reason || "no reason";
            setStatus("closed", `${event.code}`);
            log("system", `Socket closed (${event.code}) - ${reason}`);
            await stopMicStream();
          };

          ws.onerror = () => {
            setStatus("error");
            log("error", "WebSocket error.");
          };

          ws.onmessage = (event) => {
            const text = String(event.data);
            log("in", text);

            const parsed = parseJson(text);
            if (!parsed || typeof parsed !== "object") return;

            if (parsed.type === "PairSuccess" && parsed.token) {
              els.tokenInput.value = parsed.token;
              savePrefs();
              updateBadges();
            }

            if (parsed.type === "SessionCreated" && parsed.session_id) {
              els.sessionId.value = parsed.session_id;
              savePrefs();
              updateBadges();
              resetSessionOutputState();
            }

            if (parsed.type === "Diagnostics" && parsed.data) {
              const d = parsed.data;
              const compactions = Number(d.compactions_applied_total || 0);
              const reconnects = Number(d.reconnect_attempts_total || 0);
              const allowlistSize = Number(d.security_principal_allowlist_size || 0);
              const denyDefault = Boolean(d.security_deny_by_default_principal_allowlist);
              const publicBind = Boolean(d.security_allow_public_bind);
              els.diagBadge.textContent = `diag: rc=${reconnects} cp=${compactions}`;
              els.secBadge.textContent =
                `sec: deny=${denyDefault ? "on" : "off"} allow=${allowlistSize} bind=${publicBind ? "public" : "local"}`;
              if (d.security_workspace_root) {
                log(
                  "system",
                  `Diagnostics security: workspace=${d.security_workspace_root} forbidden=${(d.security_forbidden_tool_paths || []).join(",")}`
                );
              }
              syncTemplateOptions(d.supported_client_messages);
            }

            if (parsed.type === "GatewayHealth" && parsed.data) {
              const h = parsed.data;
              const pairing = h.require_pairing ? "pair" : "open";
              const up = Number(h.uptime_seconds || 0);
              const sessions = Number(h.active_sessions || 0);
              const p = Number(h.active_priority_bindings || 0);
              els.healthBadge.textContent = `gw: up=${up}s s=${sessions} p=${p} ${pairing}`;
            }

            if (parsed.type === "PriorityNotice" && parsed.data) {
              const p = parsed.data;
              const code = p.code || "notice";
              const level = p.level || "info";
              els.prioBadge.textContent = `prio: ${code} (${level})`;
            }

            if (parsed.type === "AudioAccepted" && parsed.session_id && parsed.session_id === activeSessionId()) {
              voiceCounters.accepted += 1;
              els.audioProgress.textContent = `ack ${voiceCounters.accepted}`;
            }

            if (parsed.type === "AudioCommitted" && parsed.session_id && parsed.session_id === activeSessionId()) {
              els.audioProgress.textContent = "committed";
            }

            if (
              parsed.type === "ResponseCreateAccepted" &&
              parsed.session_id &&
              parsed.session_id === activeSessionId()
            ) {
              els.audioProgress.textContent = "response requested";
            }

            if (
              parsed.type === "ResponseInterruptAccepted" &&
              parsed.session_id &&
              parsed.session_id === activeSessionId()
            ) {
              setPlaybackStatus("interrupted");
            }

            if (parsed.type === "SessionToolResult" && parsed.session_id && parsed.session_id === activeSessionId()) {
              els.toolResultView.value = JSON.stringify(parsed.result ?? {}, null, 2);
              els.graphTraceView.value = formatGraphReport(parsed.graph);
              els.toolResultView.scrollTop = 0;
              els.graphTraceView.scrollTop = 0;
            }

            if (parsed.type === "TranscriptUpdate" && parsed.session_id && parsed.session_id === activeSessionId()) {
              voiceCounters.transcript += 1;
              appendTranscript(parsed.text || "", Boolean(parsed.is_final));
            }

            if (parsed.type === "AudioOutput" && parsed.session_id && parsed.session_id === activeSessionId()) {
              try {
                lastAudioOutputBytes = base64ToBytes(parsed.audio || "");
                voiceCounters.audioOutput += 1;
                setPlaybackStatus(`${voiceCounters.audioOutput} evt`);
                if (els.autoPlayOutput.checked) {
                  playPcm16Chunk(lastAudioOutputBytes).catch((err) => {
                    log("error", `Auto-play failed: ${err.message}`);
                  });
                }
              } catch (err) {
                log("error", `Failed to decode AudioOutput: ${err.message}`);
              }
            }
          };
        }

        function disconnect() {
          if (!ws) return;
          ws.close(1000, "Closed by user");
        }

        function buildCreateSessionMessage() {
          const cfg = {};
          const role = els.roleSelect.value;
          const model = els.modelInput.value.trim();
          const voice = els.voiceInput.value.trim();
          const graph = els.graphToggle.value;

          if (role) cfg.role = role;
          if (model) cfg.model = model;
          if (voice) cfg.voice = voice;
          if (graph === "true") cfg.enable_graph = true;
          if (graph === "false") cfg.enable_graph = false;

          return {
            type: "CreateSession",
            config: Object.keys(cfg).length > 0 ? cfg : null,
          };
        }

        els.connectBtn.addEventListener("click", connect);
        els.disconnectBtn.addEventListener("click", disconnect);

        els.pairBtn.addEventListener("click", () => {
          const code = els.pairCode.value.trim();
          if (!code) {
            log("error", "Pairing code is empty.");
            return;
          }
          sendObject({ type: "Pair", code });
        });

        els.authBtn.addEventListener("click", () => {
          const token = els.tokenInput.value.trim();
          if (!token) {
            log("error", "Token is empty.");
            return;
          }
          sendObject({ type: "Authenticate", token });
          savePrefs();
          updateBadges();
        });

        els.createSessionBtn.addEventListener("click", () => {
          sendObject(buildCreateSessionMessage());
        });

        els.pingBtn.addEventListener("click", () => {
          sendObject({ type: "Ping" });
        });

        els.healthBtn.addEventListener("click", () => {
          sendObject({ type: "GetGatewayHealth" });
        });

        els.priorityBtn.addEventListener("click", () => {
          sendObject({ type: "PriorityProbe" });
        });

        els.diagnosticsBtn.addEventListener("click", () => {
          sendObject({ type: "GetDiagnostics" });
        });

        els.terminateBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          sendObject({ type: "TerminateSession", session_id: sid });
          stopMicStream().catch((err) => {
            log("error", `Mic stop failed: ${err.message}`);
          });
        });

        els.sendB64Btn.addEventListener("click", () => {
          const sid = activeSessionId();
          const audio = els.audioB64.value.trim();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          if (!audio) {
            log("error", "Base64 audio payload is empty.");
            return;
          }
          sendObject({ type: "SessionAudio", session_id: sid, audio });
        });

        els.sendFileBtn.addEventListener("click", () => {
          sendFileAsAudioChunks().catch((err) => {
            els.audioProgress.textContent = "error";
            log("error", `Audio stream failed: ${err.message}`);
          });
        });

        els.micStartBtn.addEventListener("click", () => {
          startMicStream().catch((err) => {
            log("error", `Mic stream start failed: ${err.message}`);
          });
        });

        els.micStopBtn.addEventListener("click", () => {
          stopMicStream().catch((err) => {
            log("error", `Mic stream stop failed: ${err.message}`);
          });
        });

        els.playLastBtn.addEventListener("click", () => {
          playLastOutput().catch((err) => {
            log("error", `Playback failed: ${err.message}`);
          });
        });

        els.commitAudioBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          sendObject({ type: "SessionAudioCommit", session_id: sid });
        });

        els.createResponseBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          sendObject({ type: "SessionResponseCreate", session_id: sid });
        });

        els.interruptResponseBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          sendObject({ type: "SessionResponseInterrupt", session_id: sid });
        });

        els.callToolBtn.addEventListener("click", () => {
          const sid = activeSessionId();
          if (!sid) {
            log("error", "Session ID is empty.");
            return;
          }
          const toolName = els.toolName.value.trim();
          if (!toolName) {
            log("error", "Tool name is empty.");
            return;
          }
          const args = parseJson(els.toolArgs.value);
          if (args === null) {
            log("error", "Tool arguments must be valid JSON.");
            return;
          }
          sendObject({
            type: "SessionToolCall",
            session_id: sid,
            tool_name: toolName,
            arguments: args,
          });
        });

        els.sendRawBtn.addEventListener("click", () => {
          const obj = parseJson(els.rawJson.value);
          if (obj) sendObject(obj);
        });

        els.loadTemplateBtn.addEventListener("click", () => {
          const type = els.templateType.value;
          const template = templateForType(type);
          els.rawJson.value = JSON.stringify(template, null, 2);
        });

        els.rawJson.addEventListener("keydown", (event) => {
          if ((event.ctrlKey || event.metaKey) && event.key === "Enter") {
            event.preventDefault();
            els.sendRawBtn.click();
          }
        });

        els.clearLog.addEventListener("click", () => {
          els.log.innerHTML = "";
        });

        [els.wsUrl, els.tokenInput, els.sessionId].forEach((el) => {
          el.addEventListener("input", () => {
            savePrefs();
            updateBadges();
          });
        });

        window.addEventListener("beforeunload", () => {
          stopMicStream().catch(() => {});
        });

        loadPrefs();
        setStatus("closed");
        setMicStatus("idle");
        setPlaybackStatus("idle");
        log("system", "Ready. Connect, Pair/Auth, then CreateSession.");
      })();
    </script>
  </body>
</html>
